RESTORE UN ARCHIVO A UNA VERSIÓN ANTERIOR

Supongamos que ejecutamos las siguientes lineas:
		git rm file1.txt
		git status -s

Nos devuelve "D file1.txt" con D en verde ya que hay un archivo borrado en el dir local, también borrado en la SA pero no commitido el cambio. Luego hacemos un:
		git commit -m "Archivo borrado"

Ahora subimos una snapshot de nuestro proyecto, sin ese archivo que ya fue borrado. Que pasa si nos arrepentimos y queremos ese archivo de nuevo ? Si tiramos un:
		git log --oneline
veremos:
		96290c7 (HEAD -> master) Borre file1
		37035e6 Agrego nueva carpeta y nuevo txt
		32f8672 Mensaje
		e7fad22 Primer commit

Ahora queremos restarurar el file1.txt del último commit donde existiese (37035e6) podemos hacer un restore de la siguiente manera:
		git restore --source=HEAD~1 file1.txt

Este hace un restore desde la source tomando el commit de 1 linea anterior a la HEAD. Si ahora tiramos un status -s veremos:
		?? file1.txt

Luego tendremos que hacer un add y un commit para volver a agregarlo en todos los niveles.

-------------------

	FILTRAR HISTORIAL:

Podemos filtrar las búsquedas de muchas maneras, algunos ejemplos: (se les puede agregar --oneline o --patch a TODOS, puse solo en algunos, oneline tira menos detalles de cada commit, y --patch tira los cambios de cada commit)

											MUESTRA LOS COMMITS:
		git log --oneline -3 				//de los últimos 3 días
		git log --author "Ale"				//de un autor en especial
		git log --after="2022-05-01"		//por fecha YYYY-MM-DD
		git log --after="yesterday"
		git log --after="two weeks ago"
		git log --grep="GUI"				//que tengan GUI en el mensaje (ES CS)
		git log -S"OBEJCTIVES"				//que hayan agregado o eliminado una linea con "OBJECTIVES"
		git log -S"OBEJCTIVES" --patch		//lo mismo que el anterior pero con los cambios
		git log fb54d..d1e5q				//desde un commit con ID fd54d hasta otro con ID d1e5q
		git log toc.txt						//que modificaron toc.txt
	Si este último caso tira error por ambiguedad se puede agregar -- antes del archivo que queremos consultar -- toc.txt

Si queremos consultar toda la gente que trabajó en un proyecto podemos correr:
		git shortlog

Y nos devolverá el nombre de cada persona que hizo un commit, la cantidad de commits que hizo y todos los mensajes de los commits que hizo. Podemos agregarle -n para ver solo los nombres de la gente que trabajó ordenado por mayor cantidad de commits. Podemos agregar -e para agregarle el correo también de cada persona.


-------------------

	FORMATTING LOG OUTPUT:

Para cambiar el formato en que se muestran los outputs podemos setear:
		git log --pretty=format:""

Y entre los "" podemos poner por ej "%an committed %H", y veremos el nombre del autor (an) la palabra "committed" seguido por el hash completo (o ID) del commit. Para usar el short hash usamos %h (7 dígitos). Hay 10 millones de cosas para poner como '%cd' que es fecha del commit, y otras que se puden buscar en google. Hasta se puede colorear cada palabra poniendo por ej "%Cgreen%an%Creset" para que el autor del nombre salga de otro color.

-------------------

	ALIAS

En git podemos usar aliases para comandos que usamos muy seguido de las siguiente manera:
		git --global alias.lg "log --pretty=format:'%an committed %h'"

--global significa que es global, alias.nombre define el nombre del alias (en el caso anterior es lg) y lo que está entre comillas define que queremos que haga el alias "lg". Si abrimos:
		git --global -e
veremos una nueva sección:
		[alias]
			lg: log --pretty=format:'%an committed %h'

Y si ahora hacemos un "git lg" veremos lo mismo que si ejectuamos toda la línea guardad entre comillas. Un ejemplo práctico es:
		git config --global alias.unstage "restore --staged ."

Ahora cuando hagamos un "git unstage" vamos a hacer un restore de todos los archivos de la SA.


-------------------

	DIFERENCIAS ENTRE 2 COMMITS:

Como hacemos para ver todos los cambios entre 2 commits ? Supongamos que tiramos un log:
		git log --oneline

Y nos revuelve:
		a642e12 (HEAD -> master) Add header to all pages.
		50db987 Include the first section in TOC.
		555b62e Include the note about committing after staging the changes.
		ca49180 Initial commit.

Y queremos ver todos los cambios entre las últimas 2 lineas por ejemplo, tiramos un
		git diff HEAD~2 HEAD

Se puede agregar un --name-only para ver solo el nombre de los archivos que sufrieron cambios entre esos commits
Se puede aregar el nombre de algun archivo ("file1.txt" xej) despues del último HEAD para ver solo los cambios de un archivo
Se puede agregar --name-status para ver la lista de archivos al momento del cambio (M, A, D para modif, add o deletes)

	
-------------------

	CHEQUEANDO UN COMMIT

Podemos también revisar el snapshot de viejas versiones con el comando checkout, y debemos darle una versión mediante el ID
		git checkout 555b62e

Nos va a tirar un warning porque sacamos al HEAD del MASTER, esto es porque hasta ahora siempre HEAD y MASTER se movían juntos, pero al chequear por ej el primer commit, movemos el HEAD y lo separamos del MASTER:

                          HEAD      
                            ▼       │
                         MASTER     │    HEAD                    MASTER
                            ▼       │      ▼                       ▼
  ┌───┐   ┌───┐   ┌───┐   ┌───┐     │    ┌───┐   ┌───┐   ┌───┐   ┌───┐
  │   │◄──┤   │◄──┤   │◄──┤   │     │    │   │◄──┤   │◄──┤   │◄──┤   │
  └───┘   └───┘   └───┘   └───┘     │    └───┘   └───┘   └───┘   └───┘


Cuando separamos HEAD y MASTER hay que tener cuidado con hacer nuevos commits, ya que si hacemos un nuevo commit y después volvemos a colocar a HEAD en MASTER, ese commit (C en la fig) no se podrá alcanzar nunca, ya que no hay pointer que nos lleve, es un commit "muerto":

   HEAD
     ▼                             │
   ┌───┐                           │    ┌───┐                   HEAD 				ES MUY IMPORTANTE NUNCA HACER COMMITS NUEVOS CUANDO
   │   │                           │    │ C │                     ▼					NO ESTAMOS EN MASTER
   └─┬─┘                  MASTER   │    └─┬─┘                  MASTER
     ▼                       ▼     │      ▼                       ▼
   ┌───┐   ┌───┐   ┌───┐   ┌───┐   │    ┌───┐   ┌───┐   ┌───┐   ┌───┐
   │   │◄──┤   │◄──┤   │◄──┤   │   │    │   │◄──┤   │◄──┤   │◄──┤   │
   └───┘   └───┘   └───┘   └───┘   │    └───┘   └───┘   └───┘   └───┘

Es una buena práctica buscar estos commits muertos y eliminarlos para guardar espacio y mantener un flow limpio. Para volver al master hacemos simplemente un:
		git checkout master
	
-------------------

	BUSCANDO UN BUG CON BISECT

Es una herramienta muy poderosa. Supongamos que tenemos los siguientes commits tirando un:
		$ git log --oneline
		a642e12 (HEAD -> master) Add header to all pages.
		50db987 Include the first section in TOC.
		555b62e Include the note about committing after staging the changes.
		91f7d40 Explain various ways to stage changes.
		edb3594 First draft of staging changes.
		24e86ee Add command line and GUI tools to the objectives.
		36cd6db Include the command prompt in code sample.
		9b6ebfd Add a header to the page about initializing a repo.
		fa1b75e Include the warning about removing .git directory.
		dad47ed Write the first draft of initializing a repo.
		fb0d184 Define the audience.
		1ebb7a7 Define the objectives.
		ca49180 Initial commit.

Supongamos que en la version master tenemos un bug en nuestra aplicación. No sabemos cuando este bug se introdujo, y no vamos a chequear cada uno de los commits y cada una de las versiones para ver cuando se introdujo ese bug. Podemos entonces usar el comando bisect para encontrar el commit que introdujo el problema, para eso tenemos que darle a git un commit que sea malo, o donde el bug exista, y uno donde todavía el bug no existía (el bug se introdujo en el medio). Supongamos que en el commit inicial ca49180 no existía el bug, corremos:
		git bisect start

Entramos en modo bisect, ahora le decimos que la versión actual es mala, osea tiene el bug y luego la buena, sin bug:
		git bisect bad 
		git bisect good ca49180

Nos devuelve:
		Bisecting: 5 revisions left to test after this (roughly 3 steps)
		[36cd6db402cfd897810d4cb33d97ac1e9d1ce2d8] Include the command prompt in code sample.

En este caso nos tira que hay 5 revisiones y requiere 3 steps, y también nos notificará que no estamos más en MASTER, en nuestro caso estamos en "36cd6db".
Si ahora tiramos un:
		git log --online --all

Nos devuelve lo siguiente, indicando que el HEAD no está atachado a MASTER:	
		a642e12 (master, refs/bisect/bad) Add header to all pages.								//MATER arriba de todo //MAL COMMIT
		50db987 Include the first section in TOC.
		555b62e Include the note about committing after staging the changes.
		91f7d40 Explain various ways to stage changes.
		edb3594 First draft of staging changes.
		24e86ee Add command line and GUI tools to the objectives.
		36cd6db (HEAD) Include the command prompt in code sample.								//HEAD en el commit 36cd6db
		9b6ebfd Add a header to the page about initializing a repo.
		fa1b75e Include the warning about removing .git directory.
		dad47ed Write the first draft of initializing a repo.
		fb0d184 Define the audience.
		1ebb7a7 Define the objectives.
		ca49180 (refs/bisect/good-ca4918083ec471878d58612142572f3367faf5fd) Initial commit.		//BUEN COMMIT

Esto significa que estamos haciendo un checkout de la versión 36cd6db, por lo que podemos correr nuestra aplicación y ver si el bug todavía sigue, si el bug está todavía presente sabemos que el bug se introdujo en la segunda mitad, si el bug no existe, sabemos que se introdujo en la mitad de arriba (committs más recientes).
Supongamos que el bug no está presente todavía, volvemos a decirle a git que este commit es bueno:
		git bisect good

Ahora nos devuelve:
		Bisecting: 2 revisions left to test after this (roughly 2 steps)
		[91f7d40d6d5bbc336a271607a0488216aaf50cd7] Explain various ways to stage changes.

Que nos indica que quedan 2 revisiones para terminar, y que estamos parados en 91f7d40. Y volvemos a repertir todos los pasos. Un nuevo log tira:
		a642e12 (master, refs/bisect/bad) Add header to all pages.								//MASTER //MAL COMMIT
		50db987 Include the first section in TOC.
		555b62e Include the note about committing after staging the changes.					
		91f7d40 (HEAD) Explain various ways to stage changes.									//HEAD
		edb3594 First draft of staging changes.
		24e86ee Add command line and GUI tools to the objectives.
		36cd6db (refs/bisect/good-36cd6db402c) Include the command prompt in code sample.		//BUEN COMMIT
		(y abajotodos los commits que ya no nos interesa)

Supongamos que volvemos ac orrer la app y el bug no está todavía, de nuevo le decimos que es un buen commit, el log nos devuelve:
		a642e12 (master, refs/bisect/bad) Add header to all pages.								//MASTER //MAL COMMIT
		50db987 (HEAD) Include the first section in TOC.										//HEAD
		555b62e Include the note about committing after staging the changes.
		91f7d40 (refs/bisect/good-91f7d40d6d5bb) Explain various ways to stage changes.			//BUEN COMMIT

Entonces ya sabemos que el bug fue introducido o en el commit 50db987 o en el 555b62e, por lo que debemos testear nuevamente nuestra app y probar por última vez. Si tiramos un bad por ejemplo nos devolverá un resumen del commit malo:
		555b62e1ebb92c97fc69910ad0981a7d6dbbf8c6 is the first bad commit
		commit 555b62e1ebb92c97fc69910ad0981a7d6dbbf8c6
		Author: Moshfegh Hamedani <moshfegh@live.com.au>
		Date:   Mon Aug 17 14:26:49 2020 -0700

		    Include the note about committing after staging the changes.

		 sections/creating-snapshots/staging-changes.txt | 2 ++
		 1 file changed, 2 insertions(+)

Una vez que terminamos para volver a master y terminar el proceso de bisect ejecutamos:
		git bisect reset


-------------------

	HISTORIAL Y RETAURACIÓN DE UN ARCHIVO

Supongamos que elimnamos un archivo toc.txt, podemos buscar el historial como ya vimos:
		git log --oneline --toc.txt

Nos devuelve todos los commits que tocaron ese archivo:
		a1adece (HEAD -> master) Remuevo toc
		a642e12 Add header to all pages.
		50db987 Include the first section in TOC.
		ca49180 Initial commit.

Obvio que el último commit es el que lo eliminó así que no lo contiene, por lo que si queremos restaurarlo tendremos que tomarlo del commit a642e12 que es el que contiene la última versión de toc.txt, y hacemos un checkout:
		git checkout a642e12 toc.txt

Ahora si tiramos un status nos devolverá "A toc.txt" con A en verde ya que habrá un nuevo archivo que está en la SA y en el local dir, pero no en la última versión commiteada, por lo que hay que commitirlo con un "git commit -m 'Restauro toc.txt'""

-------------------

	BLAME

Blame sirve para ver quien escribió alguna linea, supongamos que hay algo raro en las primeras 3 lineas del archivo audience.txt, podemos correr:
		git blame -L 1,3 audience.txt		(si agregamos -e después del blame, nos tira el email en vez del nombre)

Y nos devuelve:
		a642e122 (Moshfegh Hamedani 2020-08-18 09:23:19 -0700 1) AUDIENCE
		a642e122 (Moshfegh Hamedani 2020-08-18 09:23:19 -0700 2)
		fb0d184c (Moshfegh Hamedani 2020-08-17 14:18:09 -0700 3) This course is for anyone who wants to learn Git.

vendiendo a quien escribó cada linea y cuando, y en que commit se agregó


-------------------

	TAGGING

A veces es útil tener ciertos bookmarks, o algunos commits que representan un punto importante, como una versión nueva por ej. Para eso se usan las tags. Supongamos que el commit actual representa la primera versión de nuestro software:
		git log --oneline
		8f23583 (HEAD -> master) Restauro toc.txt
		a1adece Remuevo toc
		a642e12 Add header to all pages.
Aplicamos el tag:
		git tag v1.0 a1adece

Ahora al tirar un log veremos el nuevo tag:
		8f23583 (HEAD -> master) Restauro toc.txt
		a1adece (tag: v1.0) Remuevo toc
		a642e12 Add header to all pages

También podemos referenciar el commit con el nuevo tag, por ejemplo tirando un "git checkout v1.0". Para ver todas las tags que tenemos podemos ejecutar:
		git tag

También existe otro tipo de tag llamado "annotated" tag, donde éste tag es un objeto con muchas propiedades como nombre del tagger, email y/o mensaje. Para hacerlo agregamos un -a y un mensaje al final (en este caso no pongo el ID del commit porque estoy tageando HEAD>MASTER que es donde estoy parado, solo hay que poner el ID para hacer referencia a commits viejos)
		git tag -a v1.1 -m "Mensaje para versión 1.1"

Ahora si tiramos "git tag" solo vemos una lista de las versiones, y si tiramos "git tag -m" veremos los mensajes, y en el caso de tags sin mensajes, el mensaje del commit de ese tag. En este caso:
		v1.0 	Remuevo toc
		v1.1    Mensaje para versión 1.1

Y podemos ver el detalle del tag "annotated" con un show:
		git show v1.1

Y nos mostrará todos los detalles del tag:
			tag v1.1
			Tagger: Ale Leone <ale.leone09@gmail.com>
			Date:   Wed Sep 21 19:19:31 2022 -0300
			Mensaje para versión 1.1
			
			commit 8f235830d2550aaca873e882d31149cdd34a7ee2 (HEAD -> master, tag: v1.1)
			Author: Ale Leone <ale.leone09@gmail.com>
			Date:   Wed Sep 21 19:03:31 2022 -0300

			    Restauro toc.txt

			diff --git a/toc.txt b/toc.txt
			new file mode 100644
			index 0000000..cc0798f
			--- /dev/null
			+++ b/toc.txt
			@@ -0,0 +1,5 @@
			+TABLE OF CONTENT
			+
			+Creating Snapshots
			+  - Initializing a repository
			+  - Staging changes

Para eliminar un tag lo hacemos con:
		
		git tag -d v1.1


=======================================================================

	BRANCHING

Branching nos permite desviarnos de la lina principal de trabajo y trabajar en algo de forma aislada. Conceptualmente se puede pensar como un espacio de trabajo seprado. Una vez que trabajamos por ejemplo en una nueva feature y queremos agreagar esta feature a MASTER, volvemos a la main line haciendo un merge. Esto es también para no tocar tanto el MASTER y hacerlo lo más estable posible. Las branches son bastante lentas normalmente, pero GIT es super efciente al respecto y por eso se usa tanto. 
Supongamos que tenemos un bug, para arreglar este bug primero deberíamos crear una nueva branch, y lo hacemos con:
		git branch bugfix

Para ver la lista de las diferentes branches podemos ejectura solo "git branch". Nos devolverá algo similar a esto:
		bugfix
		*master

El asterisco indica que nuestro HEAD está en MASTER (nuestro head reperesenta donde estamos parados nosotros). Para cambiar a la branch bugfix hacemos:
		git switch bugfix

No es recomendable nombrar de esta manera las  braches, los nombres deben ser descriptivos, para cambiar el nombre de una branch ejecutamos:
		git branch -m bufix bugfix/signup-form			//-m viejonombre nuevonombre

En nuestro ej modificamos 3 lineas de audience.txt (un add, un modif y un del). Si tiramos un status nos mostrará en rojo el archivo audience.txt ya que fue modificado y no está en la SA. Depsués hacemos un add y un commit:
		git add .
		git commit -m "Fix the bug that prevented the users from signin up

Ahora si tiramos un 'git log --oneline' veremos:

		f9212c2 (HEAD -> bugfix/signup-form) Fix the bug that prevented the users from signin up
		8f23583 (master) Restauro toc.txt
		a1adece Remuevo toc
		a642e12 Add header to all pages.
		50db987 Include the first section in TOC.

Vemos que HEAD está en la branch bugfix y hace referencia al commit f922 pero MASTER quedó un commit atrasado. 

                          MASTER
                            ▼
  ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐
  │   │◄──┤   │◄──┤   │◄──┤   │◄──┤   │
  └───┘   └───┘   └───┘   └───┘   └───┘
                          			▲
                                  bugfix

Entonces si ahora hacemos un
		git switch 
		code audience.txt

Veremos la versión anterior del archivo, sin los 3 cambios que hicimos ya que MASTER todavía está en ese snapshot, y si tiramos un log, veremos lo mismo que antes pero sin el último commit, para ver los commits posteriores a donde estamos parados tenemos que agregarle '--all'.
Una vez que terminamos de usar una branch la eliminamos de la siguiente manera:
		git branch -d bugfix/signup-form

Si la branch no está mergeada nos tirará un error ya que hay cambios en la branch bugfix que no están en la MASTER. Si estamos seguros que queremos deshacer esos cambios y no mergearlos con MASTER podemos forzar la eliminación usando una -D en vez de -d. 


	COMPARANDO BRANCHES:

Podemos ver todos los commits que están en la branch bugfix y no en MASTER usando el comando:
		git log --oneline master...bugfix/singup-form

Nos devolverá lo mismo que log, pero solo desde MASTER hasta bugfix. Podemos sacarle el --oneline o agregarle --patch para ver más detalles de los commits realizados. Si queremos ver la diferencia entre todos los commits podemos verlo con 'git diff' en vez de log. Como en este caso estamos parados en MASTER no hace falta aclararlo al principio, podemos hacer directamente:
		git diff bugfix/singup-form

Para ver CUALES ARCHIVOS fueron modificados, agregamos '--name-only' o '--name-status' después del diff.


-------------------


	STASHING

Cuando hacemos un switch, GIT restaura nuestro directorio con los archivos de la snapshot del último commit de esa branch. Si tenemos cambios en nuestro directorio que no hayamos commitido todavía, GIT no nos dejerá hacer el cambio de branch porque perderíamos todos esos cambios sin guardar.
Si no queremos perder los cambios, pero tampoco queremos hacer un commit, podemos guardar estos cambios en un stash con el comando:
		git stash push -m "Mensaje"

Tener cuidado porque los archivos nuevos que no se hayan comitido nunca no se guardarán en el stash, solamente se guardarán lo cambios. Antes de guardar un stash podemos tirar un 'git status -s' y asegurarnos que ninguna linea aparece con '??' que significa que hay un archivo que no está ni en el SA ni fue commitido nunca. En el caso de que tuviesemos algún archivo de este tipo podemos agregar la label --all o -a antes del -m (o combinar ambas opciones con -am)para forzar también a hacer un stash de los archivos nuevos. Para ver las stashes hacemos un:
		git stash list

Nos devuelve los stash con indicadores únicos:
		stash@{0}: On master: "Mensaje segundo stash"
		stash@{1}: On master: "Mensaje primer stash"

Ahora si podemos cambiar de branch y no perderemos ningún dato, y podemos trabajar tranquilamente. Supongamos que nos movimos a bugfix y volvimos a master. Ahora queremos aplicar un stash con la que estabamos trabajdno antes a MASTER, podemos ver el contenido del stash con:
		git stash show stash@{1}	// o directamente 'show 1'

Nos devuelve los archivos cambiados, insertions y deletions. Luego podemos aplicar los cambios, y luego podemos borrar el stash ya usado y sin futuro uso:
		git stash apply 1
		git stash drop 1

Para remover más de un stash podemos hacer un 'git stash clear'


-------------------


	MERGING O MERGEO:

En GIT hay 2 tipos de merges:

-		Fast foward merges: Un FFM es cuando creamos una branch nueva, pero no nos desviamos a otras ramas por lo que lo único que tenemos que hacer para mergear es mover el MASTE hacia el último commit de nuestro branch.

	                 MASTER
	                   ▼
	 ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐
	 │   │◄──┤   │◄──┤   │◄──┤   │◄──┤   │
	 └───┘   └───┘   └───┘   └───┘   └───┘
	                                   ▲
	                                 bugfix
	                                 (HEAD) 

Esto es lo que venimos haceidno en los ejemplos anteriores, tenemos por ej una versión MASTER v1.0, luego hacemos un branch bugfix, hacemos ciertos cambios y tenemos una nueva versión v1.2. Si queremos mergear lo único que tenemos que hacer es asignarle MASTER a esta branch y listo, solo cambiamos el pointer MASTER al último commit v1.2. Después borramos el pointer "bugfix" y listo.

-		3 way merges: Es el mismo caso anterior pero después de que creamos una nueva branch y nos pusimos a trabajar en branch, nosotros o alguien más hizo un nuevo commit en master, por lo que nuestra branch bugfix tiene su primer pointer a un commit viejo de master.


                                 MASTER          │                                                 MASTER
                                   ▼             │                                                   ▼
  ┌───┐   ┌───┐   ┌───┐   ┌───┐  ┌───┐           │   ┌───┐   ┌───┐   ┌───┐   ┌───┐  ┌───┐          ┌───┐
  │   │◄──┤   │◄──┤   │◄──┤   │◄─┤   │           │   │   │◄──┤   │◄──┤   │◄──┤ A │◄─┤ B │◄─────────┤   │(MERGE COMMIT)
  └───┘   └───┘   └───┘   └───┘  └───┘           │   └───┘   └───┘   └───┘   └───┘  └───┘          └─┬─┘
                            ▲                    │                             ▲                     │
                            │    ┌───┐   ┌───┐   │                             │    ┌───┐   ┌───┐    │
                            └────┤   │◄──┤   │   │                             └────┤   │◄──┤ C │◄───┘
                                 └───┘   └───┘   │                                  └───┘   └───┘
                                           ▲     │                                            ▲
                                         bugfix  │                                          bugfix


Entonces tenemos cambios en MASTER que no están en la branch bugfix. En este caso cuando hacemos un merge, se crea un nuevo commit que combina estas 2 branches. Se llama 3 way merge porque este nuevo commit hace referencia a 3 commtis, el commiy 'A' que es el último commit en común, y los commits 'B' y 'C' que son los últimos commits de cada branch.

Para visualizar mejor las branches podemos agregar un --graph en nuestro típico log:
		git log --oneline --all --graph

Para cambiar y crear una branch al mismo tiempo podemos ejecutar:
		git switch -C bugfix/login-form			//bugfix/login-form es el nombre


	EJEMPLO 3 WAY MERGE:

Hagamos un nuevo branch, modifiquemos algo, hagamos un commit de ese branch y luego agregemos otra modificación a MASTER para hacer una divergencia de los paths:
	
		git switch -C feature/change-pass					//Creo una nueva branch
		echo hello > change-password.txt					//hacemos un cambio en la branch
		git add .											//lo agregamos a la SA
		git commit -m "Se modifico el pass form"			//hacemos un commit del cambio en el branch
		git log --online --all --graph

Con todos estos cambios veremos lo siguiente; HEAD está en la nueva branch que está un paso adelante de MASTER, pero siguen sin diverger:

		* 92fe8b2 (HEAD -> feature/change-pass) Se modifico el pass form
		* f9212c2 (master) Fix the bug that prevented the users from signin up

Ahora volvemos a MASTER y hacemos un nuevo commit:

		git switch master									//Vuelvo a MASTER
		code objectives.txt									//abro txt con VSCODE y lo modifico
		git add .											//agregamos los cambios al SA
		git commit -m "Cambio objectives.txt"				//hacemos el commit de master
		git log --oneline --all --graph

Ahora vemos como los caminos divergen:

		* fb5ebf3 (HEAD -> master) Cambio objetivos.txt
		| * 92fe8b2 (feature/change-pass) Se modifico el pass form
		|/
		* f9212c2 Fix the bug that prevented the users from signin up

Ahora hacemos un 3 way merge en donde git compara los últimos 2 commits con el commit f9212 que es el último commit en común. Basándose en las diferencias hará una combinación en un nuevo 'merge commit'. Parados en master escribimos:

		git merge feature/change-pass

Nos abrirá VSCODE para agregarle el mensaje a ese nuevo commit y con un nuevo log veremos lo siguiente:

		*   45b1c74 (HEAD -> master) Merge branch 'feature/change-pass'
		|\
		| * 92fe8b2 (feature/change-pass) Se modifico el pass form
		* | fb5ebf3 Cambio objetivos.txt
		|/
		* f9212c2 Fix the bug that prevented the users from signin up

Todavía tenemos el feature/change-pass con pointer en el branch, y MASTER ahora está en el nuevo merge commit.
Si borramos la branch, solo se borra el pointer (feature/change-pass) del graph de arriba, pero las divergencias siguen mostrándose y tenemos todavía todos los commits para verlos.
Podemos consultar todas las branches mergeadas y no mergeadas con los comandos:

		git branch --merged				//podemos borrarlas todas si ya dejamos de trabajar en esa branch
		git branch --no-merged


-------------------


		MERGE LINEAL SIN FAST FOWARD MERGE:

Es posible también hacer un merge sin fast foward en estos casos. Al aplicar las flags:
		git merge --no-ff bugfix

No solamente asignará a MASTER al último commit, sino que (parecido al 3 way) creará un nuevo commit (merge commit) que combina todos los cambios en el target branch y lo lleva a master. Al ejecutar la linea anterior se nos abrirá VSCODE porque tendremos que agregarle un mensaje a este nuevo commit "merge" (nos trae un mensaje por defecto "Merge branch 'bugfix' into master").
En este caso si tiramos un log con graph veremos algo así:

		* f4f1q34 (MASTER -> head) Merge branch 'bugfix' into master
		|\
		| * b46qs7d (bugfix/login-form) Update toc.txt
		|/
		* 5e7w8q9 Fix a bug...

Por lo que vemos algo parecido al 3 way merge. Hay una divergencia y luego se unen las branches. Esto tiene ciertas pros y contras 
                                                
    Cons                                        │      Pros
                                                │
  - Contamina la historia                       │    - Representa verdaderamente la historia
    (sobre todo si tenemos muchas branches)     │    - Nos permite reveritr cambios más facil
  - Se hace más dificil de leer                 │
                                                │

A que nos referimos cuando "Nos permite revertir cambios más facil". Esto es porque al crear una branch para un nuevo feature por ejemplo, y luego un nuevo commit (merge commit) al mergearlos, solo tenemos que revertir un solo commit para eliminar esa feature. En cambio si tenemos una branch lineal y el feature consta de 20 commmits, y luego movemos el pointer MASTER al último commit de la branch feature, para deshacer los cambios tenemos que volver 20 commits para atrás.
Si por ejemplo estás en un ámbito de trabajo donde no se aceptan ff merges, podemos setearlo derectamente en vez de tipiear '--no-ff' en cada commit. Para setear no ff en un repositorio solamente ejecutamos:
		git config ff no

Esto deshabilita el ff en el repositorio actual. Si agregamos --global antes de ff, lo hace para todos nuestros repos.


-------------------

	CONFLICTOS EN MERGES

Los conflictos ocurren cuando una misma linea fue cambiada de formas diferentes en branches diferentes, o cuando un archivo es modificado en una branch y borrado en otra, o cuando un archivo es agregado en 2 branches pero el contenido es diferente. En estos casos git no puede decidir como mergearlos.
Veamos un ejemplo:

		git branch -C bugfix/change-pass 				//creamos una nueva branch y la elegimos
		code change-password.txt						//abrimos el txt en VSCODE y lo editamos (agrego una linea)
		git add .
		git commit -m "Modifico change-pass.txt"
		git switch master
		code change-password.txt						//modifico el mismo archivo desde master de forma diferente
		git add .
		git commit -m "Cambio change-pass.txt"
		git merge bugfix/change-password				//intento mergear los branches desde MASTER

Nos devuelve:
		Auto-merging change-password.txt
		CONFLICT (content): Merge conflict in change-password.txt

Ahora quedamos en el medio de un proceso de MERGE, y tenemos que modificar nosotros los cambios que queremos. Para ver los archivos con conflictos más detalladamente podemos correr un git status.
En este caso abrimos change-password.txt, y como estamos en el medio del proceso de merge nos mostrará lo siguiente:

	<<<<<<< HEAD
	Cambio realizado desde MASTER
	=======
	Cambio realizado desde branch
	>>>>>>> bugfix/change-pass

VSCODE nos provee más información si nos paramos en cada linea, y arriba nos da opciones para aceptar el cambio actual (MASTER), el incoming (BRANCH) o ambos (agrega ambas lineas). También podemos modificarlo manualmente a gusto y guardar el archivo, aunque idealmente es recomendable no agregar código nuevo ya que las nuevas lineas no fueron introducidas por ninguna branch (se le llama evil commit o maligno).
Una vez modificado el txt, hay que agregarlo con un
		git add change-password.txt
		git commits 						//si no ponemos -m nos abre VSCODE para ponerlo

Y si luego tiramos un status veremos el archivo en verde ya que no tenemos ningún conflicto. Al tirar un log veremos:

		*   aa15c34 (HEAD -> master) Merge branch 'bugfix/change-pass'
		|\
		| * c3a7c91 (bugfix/change-pass) Modifico change-pass.txt
		* | 90dac1a Cambio change-pass.txt
		|/
		*   45b1c74 Merge branch 'feature/change-pass'



-------------------


	ABORTAR Y DESHACER UN MERGE:

Si al momento de un merge tenemos muchos conflictos y no los podemos resolver en este momento ejecutamos:
		
		git merge --abort

Y volvemos al momento previo al decidir el merge.
En el caso de que hicimos un merge y nuestra app se rompió por ejemplo, o no compila, podemos deshacer un merge. Supongamos que tenemos las branches anteriores:

		*   aa15c34 (HEAD -> master) Merge branch 'bugfix/change-pass'
		|\
		| * c3a7c91 (bugfix/change-pass) Modifico change-pass.txt
		* | 90dac1a Cambio change-pass.txt
		|/
		*   45b1c74 Merge branch 'feature/change-pass'

Y en este caso supongamos que el merge aa15c34 es un merge defecuoso y queremos deshacerlo, podemos hacerlo de 2 opciones:

1)	La primera es deshacer el commit y borrarlo, como si nunca lo hubiesemos hecho. Ojo con hacer esto en un repo donde trabaja mucha gente ya que es muy confuso para la gente que trabaja con estas branches, estamos re escribiendo la historia de estas branches. Al hacer esto nos quedará un commit "M" muerto, o basura, cada tanto GIT busca estos commits y los elimina ya que no tienen ningún pointer que nos pueda volver a llevar a ese commit.

                                 HEAD    │           HEAD
                                   ▼     │             ▼
                                 MASTER  │           MASTER
                                   ▼     │             ▼
   ┌───┐   ┌───┐                 ┌───┐   │   ┌───┐   ┌───┐                 ┌───┐
   │   │◄──┤   │◄────────────────┤ M │   │   │   │◄──┤   │◄────────────────┤ M │
   └───┘   └───┘                 └─┬─┘   │   └───┘   └───┘                 └─┬─┘
             ▲                     │     │             ▲                     │
             │    ┌───┐   ┌───┐    │     │             │    ┌───┐   ┌───┐    │
             └────┤   │◄──┤   │◄───┘     │             └────┤   │◄──┤   │◄───┘
                  └───┘   └───┘          │                  └───┘   └───┘
                            ▲            │                            ▲
                         feature         │                         feature

Básicamente vuelve el MASTER y HEAD un commit para atrás, antes del MERGE. Para hacer esto ejecutamos:
		
		git reset --hard HEAD~1

Se pueden usar diferentes opciones:
		 --soft: donde cambiamos la SNAPSHOT al último commit anterior al merge (M), pero sin cambiar el dir local ni el SA.
		 --medium: cambiamos la SNAPSHOT y la SA al último commit anterior al merge (anterior al M).
		 --hard: cambiamos el dir local, el SA y la snapshot al commit anterior al M. Este es el estado en el que estábamos antes de iniciar el merge.
Si hacemos esto y tiramos un log veremos que nos borra el merge que teníamos antes:
		
		| * c3a7c91 (bugfix/change-pass) Modifico change-pass.txt
		* | 90dac1a Cambio change-pass.txt
		|/
		*   45b1c74 Merge branch 'feature/change-pass'		

Aunque nos haya borrado el merge, todavía está en nuestro repo, por lo que podemos hacer un
		git reset --hard aa15c34
para volver a como estaba todo después del revert (hay que referenciar el commit por ID)


2) 	La otra opción y más recomendable para un ámbito que no sea local, es revertir el commit, osea crear un nuevo commit que cancela el merge indeseado. En este caso hay que aclarar a cual de los brances queremos revertir nuestro commit, a la branch 1 o a la 2:

                               MASTER
                                 ▼
 ┌───┐   ┌───┐                 ┌───┐
 │   │◄──┤ 1 │◄────────────────┤ M │
 └───┘   └───┘                 └─┬─┘
           ▲                     │
           │    ┌───┐   ┌───┐    │
           └────┤   │◄──┤ 2 │◄───┘
                └───┘   └───┘
                          ▲
                       feature

Siempre se revierte a la branch master, o sea a la 1. Esto lo hacemos con el comando:

		git revert -m 1 HEAD

Git nos abre el VSCODE porque al hacer un commit nuevo tendremos que agregar un msj y trae un mensaje por defecto bastante explicativo. Ahora con un log veremos:

		* 400df74 (HEAD -> master) Revert "Merge branch 'bugfix/change-pass'"		//COMMIT MASTER CON MERGE REVERTIDO
		*   aa15c34 Merge branch 'bugfix/change-pass'
		|\
		| * c3a7c91 (bugfix/change-pass) Modifico change-pass.txt
		* | 90dac1a Cambio change-pass.txt
		|/
		*   45b1c74 Merge branch 'feature/change-pass'


-------------------


	SQUASH MERGING:

Supongamos que hacemos una nueva branch como los casos anteriores para agregar alguna feature, pero decidimos que esa bifurcación o branch no es de buena calidad, no aporta algo significativo al proyecto, y solo ensucia el historial de commits y queremos eliminarlos pero no perder los cambios? En este caso lo que hacemos es el "squash merging" que consta en crear un nuevo commit en la linea MASTER con todos los cambios de a + b combinados. Esto no es un "merge commit" ya que no tiene las referencias típicas del mismo (2 padres, 3 way), sino que es un nuevo commit a+b que agregamos arriba de MASTER, entonces después podemos simplemente borrar la branch para que nos quede un historial mucho más limpio.

                                HEAD     │            HEAD                          │                               HEAD
                                  ▼      │              ▼                           │                                ▼
                               MASTER    │            MASTER                        │                              MASTER
                                  ▼      │              ▼                           │                                ▼
   ┌───┐   ┌───┐                ┌───┐    │    ┌───┐   ┌───┐                ┌───┐    │  ┌───┐   ┌───┐               ┌───┐
   │   │◄──┤   │◄───────────────┤ M │    │    │   │◄──┤   │◄───────────────┤a+b│    │  │   │◄──┤ A │◄──────────────┤a+b│
   └───┘   └───┘                └─┬─┘    │    └───┘   └───┘                └─┬─┘    │  └───┘   └───┘               └───┘
             ▲                    │      │              ▲                    │      │
             │   ┌───┐   ┌───┐    │      │              │   ┌───┐   ┌───┐    │      │
             └───┤ a │◄──┤ b │◄───┘      │              └───┤ a │◄──┤ b │◄───┘      │
                 └───┘   └───┘           │                  └───┘   └───┘           │
                           ▲             │                            ▲             │
                        feature          │                         feature          │                   

Como vemos en las figuras, el primer caso sería un 3 way merge donde el 'merge commit' es tiene 2 padres. En el la segunda imagen tenemos entonces un nuevo commit como explicamos, haciendo un squash merging, que básicamente es un nuevo commit con los cambios a+b. Luego solo resta mover el MASTER a este nuevo commit y eliminar la branch.

Veamos un caso real, supongamos que creamos una nueva branch y hacemos 2 commits modificando un archivo:

		git swith -C bugfix/photo-upload
		echo bugfix >> audience.txt
		git commit -am "Update audience.txt"
		echo bugfix >> toc.txt
		git commit -am "Update toc.txt"

Si ahora tiramos un graph veremos:

		* 8ba3d31 (HEAD -> bugfix/photo-upload) Update toc.txt
		* 5bec39a Update audience.txt
		* 400df74 (master) Último commit de MASTER

Nuestra branch bugfix está 2 commits adelante de MASTER, en este caso podríamos hacer un FFM pero supongamos que MATER evolucionó también, por lo que solo podemos hacer un 3wm o un squash merge. Para hacer el squash merge volvemos a la MASTER branch y agregamos --squash en merge:

		git switch master
		git branch --squash bugfix/photo-upload

Esto nos devuelve:

		Updating 400df74..8ba3d31
		Fast-forward
		Squash commit -- not updating HEAD
				 audience.txt | 2 +-
				 toc.txt      | 2 +-
				 2 files changed, 2 insertions(+), 2 deletions(-)

Esto no nos genera el commit, sino solo los cambios en la SA, si tiramos un status -s veremos:

		M  audience.txt
		M  toc.txt

Con las M en verde, que significa que los cambios están en el dir local (como ya estaban antes) y en la SA pero no fueron commitidos todavía, por lo que tenmos que hacer un nuevo commit. Este commit deberá resumir todos los cambios del branch que vamos a eliminar (commits a+b)

		git commit -m "Fix a bug on the photo upload page"		// si luego tiramos un log veremos
		git log --oneline --graph --all

Veremos que la branch todavía está, luego podemos borrar la branch, y los commits 8ba3d y 5bec3, y no perderemos ningún dato importante porque esos cambios están en el commit 5ebc. 

		* 5ebcd38 (HEAD -> master) Fix a bug on the photo upload page
		| * 8ba3d31 (bugfix/photo-upload) Update toc.txt
		| * 5bec39a Update audience.txt
		|/
		* 400df74 Último commit de MASTER

En estos casos es MUY importante borrar el branch después de hacer el squash merge ya que ese branch nunca se mergeó. Si tiramos un "branch --no-merged" vamos a ver esta branch y vamos a pensar que esos cambios no están hechos en MASTER ya que nunca los mergeamos. Cuando tiramos un
		
		git branch -d bugfix/photo-upload

Nos va a tirar error ya que no está fully merged según git por lo que hay que forzar el borrado con un -D mayúsucla. Ahora si tiramos un log veremos una linea simple, tenemos un commit que combina todos los cambios par arreglar el bug:

		* 5ebcd38 (HEAD -> master) Fix a bug on the photo upload page
		* 400df74 Último commit de MASTER


-------------------


	REBASING:

Rebasing es cambiar el pointer de la bifurcación de una feature, para que nos quede una historia lineal y poder hacer por ejemplo un FFM, y también ver una historia mucho más simple. En este caso no es muy compleja, pero en casos reales puede solucionar mucho la historia de un proyecto. Acá también hay que tener cuidado ya que rebasing reescribe historia. REBASING es recomendado solo para archivos locales en nuestro repositorio. Si compartimos commits no deberíamos usar REBASING ya que estamos haciendo mucho bardo, cambiandole la historia a todo el mundo y no van a entender nada.

                    HEAD         │                  HEAD                  │                   HEAD
                      ▼          │                    ▼                   │                     ▼
                    MASTE        │                  MASTER                │                   MASTER
                      ▼          │                    ▼                   │                     ▼
   ┌───┐   ┌───┐    ┌───┐        │ ┌───┐   ┌───┐    ┌───┐                 │  ┌───┐   ┌───┐    ┌───┐     ┌───┐   ┌───┐
   │   │◄──┤   │◄───┤   │        │ │   │◄──┤   │◄───┤   │                 │  │   │◄──┤   │◄───┤   │◄────┤ a │◄──┤ b │
   └───┘   └───┘    └───┘        │ └───┘   └───┘    └───┘                 │  └───┘   └───┘    └───┘     └───┘   └───┘
             ▲                   │                    ▲                   │                                       ▲
             │    ┌───┐   ┌───┐  │                    │    ┌───┐   ┌───┐  │                                    feature
             └────┤ a │◄──┤ b │  │                    └────┤ a │◄──┤ b │  │
                  └───┘   └───┘  │                         └───┘   └───┘  │
                            ▲    │                                   ▲    │
                         feature │                                feature │

Como vemos en el gráfico, al hacer un rebasing de la branch feature del 2do commit al 3ro, tenemos una historia lineal, por lo que podemos hacer un FFM para llevar a MASTER hasta el pointer feature.
Como dijimos, hay que tener cuidado con esto ya que cuando hacemos un rebasing, en realidad GIT crea nuevos commits a* y b* de forma lineal después del último commit, y mueve el pointer feature al último commit copiado:

                   HEAD                  │                  HEAD                    │                  HEAD
                     ▼                   │                    ▼                     │                    ▼
                   MASTER                │                  MASTER         feature  │                  MASTER         feature
                     ▼                   │                    ▼               ▼     │                    ▼               ▼
  ┌───┐   ┌───┐    ┌───┐                 │ ┌───┐   ┌───┐    ┌───┐   ┌───┐   ┌───┐   │ ┌───┐   ┌───┐    ┌───┐   ┌───┐   ┌───┐
  │   │◄──┤   │◄───┤   │                 │ │   │◄──┤   │◄───┤   │◄──┤ a*│◄──┤ b*│   │ │   │◄──┤   │◄───┤   │◄──┤ a │◄──┤ b │
  └───┘   └───┘    └───┘                 │ └───┘   └───┘    └───┘   └───┘   └───┘   │ └───┘   └───┘    └───┘   └───┘   └───┘
                     ▲                   │                    ▲                     │
                     │    ┌───┐   ┌───┐  │                    │    ┌───┐   ┌───┐    │
                     └────┤ a │◄──┤ b │  │                    └────┤ a │◄──┤ b │    │
                          └───┘   └───┘  │                         └───┘   └───┘    │
                                    ▲    │                                          │
                                 feature │                                          │


si miramos a nuestro viejo commit b, no tenemos ningún pointer o branch, por lo que en algún momento, git automáticamente borrará es te commit. También, si compartimos los commits a o b originales, y otras personas hicieron nuevos commits sobre estos commits compartidos, vamos a tener muchos problemas para aplicarlos sobre el proyecto con rebasing. Para hacer un rebasing supongamos que tenemos la siguiente bifurcación:

		* 5ebcd38 (HEAD -> master) Update toc.txt
		| * 8ba3d31 (feature/shopping-cart) Add cart.txt
		|/
		* 400df74 Último commit de MASTER

Ahora queremos cambiar la base del commit 8ba3d al último commit de master. Nos aseguramos que estamos en la branch master y hacemos un rebase

		git switch feature/shoppig-cart
		git rebase master

Ahora veremos un log sin divergencia y con camino lineal:

		* 8ba3d31 (HEAD -> feature/shopping-cart) Add cart.txt
		* 5ebcd38 (master) Update toc.txt
		* 400df74 Último commit de MASTER

Esto nos permitirá poder hacer un FFM en el futuro por ejemplo:

		git switch master
		git merge feature/shopping-cart
		git log --oneline --graph

Veremos:
		* 8ba3d31 (HEAD -> master, feature/shopping-cart) Add cart.txt
		* 5ebcd38 Update toc.txt
		* 400df74 Último commit de MASTER

Esto siempre trae conflictos, los rebasings nunca son tan sencillos. Vamos a tener que resolverlos con una mergetool más facilmente.


-------------------

	CHERRY PICKING

Esto se hace cuando por ejemplo tenemos una divergencia de la siguiente forma:

                  MASTER       │                          MASTER
                    ▼          │                            ▼
 ┌───┐   ┌───┐    ┌───┐        │ ┌───┐   ┌───┐    ┌───┐   ┌───┐
 │   │◄──┤   │◄───┤   │        │ │   │◄──┤   │◄───┤   │◄──┤ a │
 └───┘   └───┘    └───┘        │ └───┘   └───┘    └───┘   └───┘
           ▲                   │           ▲
           │    ┌───┐   ┌───┐  │           │    ┌───┐   ┌───┐
           └────┤ a │◄──┤ b │  │           └────┤ a │◄──┤ b │
                └───┘   └───┘  │                └───┘   └───┘
                          ▲    │                          ▲
                       feature │                       feature

Y decidimos por ejemplo que hay cambios interesantes en el commit 'a' que queremos llevar a MASTER pero sin hacer un full branch merge, o sin aplicar todos los cambios de la branch feature todavía. Supongamos que tenemos el siguiente log:

		
		* 5ebcd38 (HEAD -> master) Update toc.txt
		| * 7q8sq8e (feature/shopping-cart) Add colour to cart
		| * 8ba3d31 Add cart.txt
		|/
		* 400df74 Último commit antes de bifurcación

Supongamos que queremos llevar los cambios del commit 8ba3d31 a MASTER sin hacer el cambio entero, desde master hacemos un

	git cherry-pick 8ba3d31

Normalmente van a saltar conflictos que hay que resolver. Una vez que resolvemos los problemas hacemos un commit, git nos trae por defecto un mensaje relacionado al cherry pick. Ahora tendremos un nuevo commit en MASTER con este cherry pick:

		* q528a6e (HEAD -> master) Add cart.txt
		* 5ebcd38  Update toc.txt
		| * 7q8sq8e (feature/shopping-cart) Add colour to cart
		| * 8ba3d31 Add cart.txt
		|/
		* 400df74 Último commit antes de bifurcación


		SINGLE FILE CHERRY PICK:

Este cherry pick se puede hacer para un simple archivo en vez de un commit entero. Supongamos que tenemos el mismo log que antes, y en vez de copiar todo el commit 8ba3d31 solo queremos el cart.txt de este commit (supongamos que el commit tiene muchos cambios)

		* 5ebcd38 (HEAD -> master) Update toc.txt
		| * 7q8sq8e (feature/shopping-cart) Add colour to cart
		| * 8ba3d31 Add cart.txt
		|/
		* 400df74 Último commit antes de bifurcación

Para esto tenemos que estar parados en master y hacer un:

		git restore --source=feature/shopping-cart --cart.txt		//hay veces que nos pide el -- antes del archivos, hay veces que no

Ahroa git nos va a copiar 'cart.txt' del último commit del branch feature/shopping-cart en nuestro directorio local. Si tiramos un status veremos 'M cart.txt' con M en rojo ya que en nuestro directorio local tenemos el cart.txt de la branch que es distinto al de MASTER. Ahora tenemos que hacer un add y un commit para agregar el cambio a master.



============================================================================

	COLLAB

Creamos una cuenta en GIT. Ahí manejamos los repos. Para clonar un repo de GIT elegimos donde queremos pegarlo y abrimos git bash, y ejecutamos:

		git clone https://github.com/LeoneAlejandro/GitHubCourse.git 				//url en github.com

Esto nos crea una carpeta GitHubCourse en la carpeta donde abrimos bash. Si tiramos un log vemos:

		* eb163fb (HEAD -> main, origin/main, origin/HEAD) Initial commit

Vemos el único commit en este caso, pero tmb vemos origin/main y origin/head que nos da referencias de donde estaba el main y el haead orignales cuando clonamos el repo. Estos pointers no se pueden usar, son solo labels. Si tiramos 'git branch' vemos que solo tenemos una branch, la master.
Si tiramos 'git remote' vemos la lista de los repos remotos, osea repos que no estan en el dir local, que nos devolverá 'origin'.

-------------------

	FETCHING

Supongamos que el repo que copiamos es un repo donde trabajan varias personas. Tenemos que tener en cuenta que si alguien modifica el repo remoto, no sotros no veremos el cambio en nuestro repo clonado; tenemos que hacer un fetch, esto agregará los commits del repo local y moverá el origin/MASTER sin modificar nuestro MASTER o nuestro HEAD.

		git fetch

Podemos agregar 'origin branch branch/nombredebanch' en el caso de solo querer bajar una branc especial. Luego de hacer esto veremos los siguientes cambios:

        LOCAL           │       REMOTE
                        │
   MASTER               │             MASTER
     ▼                  │                ▼
   ┌───┐    ┌───┐       │    ┌───┐     ┌───┐
   │   │◄───┤   │       │    │   │◄────┤   │
   └───┘    └───┘       │    └───┘     └───┘
              ▲         │
         origin/MASTER  │
                        
Así se verán el repo local nuestro y el repo remoto después de clonar los cammits que se hicieron en el repo remoto. Aunque hayamos bajado el nuevo commit del repo remoto, no tendremos los cambios en nuestro directorio local. En nuestro directorio local tendremos la versión que apunta a MASTER. Commo podemos hacer para actualizar los cambios ? Hacemos un merge de la siguiente manera:

		git merge origin/master

Ahora nuestro repo local queda así:

		    MASTER
     		  ▼
   ┌───┐    ┌───┐
   │   │◄───┤   │
   └───┘    └───┘
              ▲
         origin/MASTER

En el caso de que MASTER y origin/MASTER tengan una divergencia, podemos tener conflictos a resolver.
Para ver un ejemplo, supongamos que editamos el README desde la web de git modificando el repo local. En el repo local tendremos 2 commits, el incial + el edit, pero en el dir local solo tendremos el readme original. Para eso hacemos un fetch

		git fetch
		git log --oneline --all --graph

Ahora en el log veremos los siguiente:

		* 3478252 (origin/main, origin/HEAD) Update README.md
		* eb163fb (HEAD -> main) Initial commit

Veremos  nuestro head en el commit viejo, el nuevo commit de origin, y los nuevos HEAD y main de origin. Podemos también ver como el branch local y el branch remoto divergen con el comando

		git branch -vv

Nos devuelve:
		
		* main eb163fb [origin/main: behind 1] Initial commit

Nuestra master o main branch está linkeada a origin, y está 1 commit atrás. Ahora tendremos que hacer un merge, en este caso un FFM

		git merge origin/main

Nos devuelve:

		Updating eb163fb..3478252
		Fast-forward
				 README.md | 3 ++-
				 1 file changed, 2 insertions(+), 1 deletion(-)

Y si vemos el log, finalmente tenemos todo actualizado:
	
		* 3478252 (HEAD -> main, origin/main, origin/HEAD) Update README.md
		* eb163fb Initial commit

-------------------

		PULLING

Pulling es la acciónde hacer un fetch y un merge al mismo tiempo. Por defecto Pull hace un merge commit en el caso de divergencias, pero podemos agregar la flag -rebase para agregar nuestros cambios locales arriba de la branch bifurcada master del repo remoto para tener una historia lineal.
Entonces supongamos que tenemos cambios tanto en el repo local como el remoto:
 

         LOCAL           │        REMOTE                          - git pull                       │  - git pull -rebase
                         │                                                              MASTER     │
             MASTER      │              MASTER                                            ▼        │
               ▼         │                 ▼                        ┌───┐    ┌───┐      ┌───┐      │     ┌───┐
    ┌───┐    ┌───┐       │     ┌───┐     ┌───┐                      │ A │◄───┤ B │◄─────┤ M │      │     │ A │
    │ A │◄───┤ B │       │     │ A │◄────┤ C │                      └───┘    └───┘      └─┬─┘      │     └───┘             MASTER
    └───┘    └───┘       │     └───┘     └───┘                        ▲                   │        │       ▲                 ▼
      ▲                  │                                            │      ┌───┐        │        │       │      ┌───┐    ┌───┐
 origin/MASTER           │                                            └──────┤ C │◄───────┘        │       └──────┤ C │◄───┤ B │
                         │                                                   └───┘                 │              └───┘    └───┘
                                                                               ▲                                    ▲
                                                                          origin/MASTER                        origin/MASTER


Acá cuando hagamos un pull vamos a tener una divergencia, por lo que cuando hagamos un pull por defecto hará un merge commit M con todos los cambios como se ve en el 3er gráfico. Si le agregamos un -rebase los cambios de nuesto repo local B se aplican luego del último commit del repo remoto C, y el resultado es un historial mucho más limpio.

Veamos un ejémplo práctico: Modificamos el README en github.com modificando el repo remoto y agregamos un file1 desde cmd para modificar también el repo local creando una bifurcación. Si tiramos un log veremos lo siguiente:
	
	* e1cc037 (HEAD -> main) Add file1.txt
	* 3478252 (origin/main, origin/HEAD) Update README.md
	* eb163fb Initial commit

Luego podemos hacer los 2 tipos de pulls, el pull normal nos da este resultado:

		*   832b0fa (HEAD -> main) Merge branch 'main' of https://github.com/LeoneAlejandro/GitHubCourse
		|\
		| * eab1893 (origin/main, origin/HEAD) Update README.md
		* | e1cc037 Add file1.txt
		|/
		* 3478252 Update README.md
		* eb163fb Initial commit

Vemos el merge commit, y como origin queda atrás tal como está todavía en el repo remoto. Después podemos ver como sería un pull -reabse haciendo un:

		git reset --hard HEAD~1

Ahora como hicimos el fetch cuando hicimos el pull, vamos a ver la bifurcación con un log:

		* e1cc037 (HEAD -> main) Add file1.txt
		| * eab1893 (origin/main, origin/HEAD) Update README.md
		|/
		* 3478252 Update README.md
		* eb163fb Initial commit

por último hacemos el 'git pull --rebase' para obtener el último log:

		* 60c27c4 (HEAD -> main) Add file1.txt
		* eab1893 (origin/main, origin/HEAD) Update README.md
		* 3478252 Update README.md
		* eb163fb Initial commit

Ahora aplicamos los cambios linealmente arriba del último commit del repo remoto, dejando un historial lineal y más sencillo. Esto es muy útil cuando son cambios locales que no compartimos con nadie para hacer el rebase.

-------------------

	PUSHING

En el caso anterior terminamos con nuestro repo local con un commit arriba de origin. Ahora queremos agregar ese commit al repo remoto; esto lo hacemos mediante un push. En los siguientes gráficos podemos ver a la izquierda el repo local y remoto previo al push, y a la derecha después del push:

         LOCAL                        REMOTE                                       LOCAL                           REMOTE
                           │                                                                            │
                   MASTER  │             MASTER                                          MASTER         │                    MASTER
                     ▼     │                ▼                                               ▼           │                       ▼
 ┌───┐    ┌───┐    ┌───┐   │    ┌───┐     ┌───┐                        ┌───┐     ┌───┐    ┌───┐         │  ┌───┐     ┌───┐    ┌───┐
 │ A │◄───┤ B │◄───┤ C │   │    │ A │◄────┤ B │                        │ A │◄────┤ B │◄───┤ C │         │  │ A │◄────┤ B │◄───┤ C │
 └───┘    └───┘    └───┘   │    └───┘     └───┘                        └───┘     └───┘    └───┘         │  └───┘     └───┘    └───┘
            ▲              │                                                                ▲           │
       origin/MASTER       │                                                           origin/MASTER
                           │

A la izq vemos el cambio en local, a la drecha vemos como se agrega ese commit en el repo remoto, y se actualiza el origin/MASTER del repo local tal como está en el remoto.
Para hacer esto tenemos que ejectuar:
	
		git push origin master

Como en este caso estamos parados en master, y git asume que pusheamos origin, podemos ejecutar solo 'git push'. Para hacer el push nos va a pedir las credenciales (email y pass). Luego vemos en la web el nuevo commit y el nuevo archivo agregado. 
A veces los push son rechazados, esto puede suceder porque justo antes de hacer el push alguien más hace un push agregando un nuevo commit al final de nuestro repo remoto (un nuevo commit D) de la siguiente manera:

         LOCAL                         REMOTE
                          │
                  MASTER  │                     MASTER
                    ▲     │                        ▲
┌───┐    ┌───┐    ┌───┐   │    ┌───┐    ┌───┐    ┌───┐
│ A │◄───┤ B │◄───┤ C │   │    │ A │◄───┤ B │◄───┤ D │
└───┘    └───┘    └───┘   │    └───┘    └───┘    └───┘
           ▼              │
      origin/MASTER       │
                          
Si hacemos un 'git push -f' estamos borrando el commit D (que es de otra persona) y reemplazandolo por el nuestro, es algo no recomendable obviamente. Lo que hay que hacer es un nuevo pull para traer el commid D a nuestro repo local, y luego un merge 3 way con un nuevo merge commit (M) o un rebase:

             Merge 									Rebase                    
                            MASTER  │      
                              ▼     │
 ┌───┐    ┌───┐    ┌───┐    ┌───┐   │    ┌───┐    ┌───┐
 │ A │◄───┤ B │◄───┤ C │◄───┤ M │   │    │ A │◄───┤ B │
 └───┘    └───┘    └───┘    └─┬─┘   │    └───┘    └───┘             MASTER
            ▲                 │     │               ▲                 ▼
            │      ┌───┐      │     │               │      ┌───┐    ┌───┐
            └──────┤ D │◄─────┘     │               └──────┤ D │◄───┤ C │
                   └───┘            │                      └───┘    └───┘
                     ▲              │                        ▲
                origin/MASTER       │                   origin/MASTER
                                    

Y después hacer un nuevo push, en el caso de un merge, estaríamos subiendo C y M al repo remoto. En el caso de Rebase solamente C, y moveríamos el origin/MASTER al commit M, en el primer caso, o C en el segundo.


-------------------


		GUARDAR CREDENCIALES

Podemos guardar las credenciales para no ingresarlas cada vez que hacemos un push. Podemos guardar nuestras credenciales en cache, que duran 15 minutos en memoria, con el comando:
	
		git congi --global credential.helper cache

O podemos guardarlas permanentemente instalando un programa 'Git credential manager for Windows' que las guarda de forma encriptada.


-------------------



		SHARING TAGS

Por defcto, push no transfiere nuestras tags al repo remoto, tenemos que pushearlas explícitamente. Suponemos que creamos una tag
	
		git tag v1.0

Ahora nuestro último commit tiene esa tag, podemos pushearla haciendo un:

		git push origin v1.0

Y podemos borrarla con un

		git push origin --delete v1.0

Ahora se eliminó del repo remoto pero sigue estando en nuestro repo local, para elimnarla hacemos un

		git tag -d v1.0 


-------------------

	SHARING BRANCHES:

Hata ahora siempre trabajamos en master, pero de la misma manera podemos trabajar en distintas branches. Cuando creamos una nueva branch en nuestro repo local, por ej:
		
		git swtich -C feature/change-pass

Esta branch no va a estar en el repo remoto. Si tiramos un push nos va a tirar un error ya que nuestra branch no está linkeada con una branch de origin. Si tramos un 'git branch -vv', veremos lo siguiente:

		* feature/change-pass 60c27c4 Add file1.txt
		  main                60c27c4 [origin/main] Add file1.txt

Como vemos tenemos el main linkeado a origin, pero nuestra nueva branch no. Podemos ver las branches del repo remoto con el comando:
	
		git branch -r

Que nos devuelve:
		
		  origin/HEAD -> origin/main
		  origin/main

Solo veremos estos 2 pointers, HEAD y MASTER del repo remoto. Si queremos pushear nuestra branch (es solamente un pointer por ahora) al repo remoto tenemos que ejectuar:
		 
		 git push -u origin feature/change-pass

En este caso tenemos -u que significa 'upset upstream', el nombre del remote al que hacemos el push, seguido por el nombre de la branch que pusheamos. Ahora si vemos en GitHub tendremos 2 branches, main y nuestra nueva branch pusheada. Ahora si tramos -vv veremos:

		* feature/change-pass 60c27c4 [origin/feature/change-pass] Add file1.txt
		  main                60c27c4 [origin/main] Add file1.txt

Ahora vemos nuestra local branch fature, linkeada con la remote branch feature subida por nosotros. También podemos volver a ver todas las branches remotas con 'git branch -r', donde vemos nuestra nueva branch subida.

		  origin/HEAD -> origin/main
		  origin/feature/change-pass
		  origin/main

Desde ahora podemos empezar a trabajar de la misma forma que estabamos trabajando con MASTE antes. Hacemos nuevos cambios en nuestro directorio local, los commitimos en nuestro repo local, y los pusheamos al repo remoto. Cuando terminamos de trabajar una branch hay que eliminarla del repo remoto también. Para esto lo hacemos con:

		git push -d origin feature/change-pass

Ahora si tiramos un -vv vemos: 

		* feature/change-pass 60c27c4 [origin/feature/change-pass: gone] Add file1.txt
		  main                60c27c4 [origin/main] Add file1.txt

Todavía tenemos la branch en nuestro repo local que también podemos eliminar como ya vimos antes, desde master hacemos:

		git switch master
		git branch -d feature/change-pass


-------------------


	COLLAB WORKFLOW

Si por ejemplo alguien más crea una nueva branch (feature/change-pass), ya sea desde su repo local y lo pushea, o desde la web, y nosotros nos bajamos la nueva versión con un fech, vamos a ver esa nueva branch desde 'git branch -r', ya que nos muestra las branchs del repo remoto, pero no vamos a poder verla desde nuestro repo local, ya que en nuestro repo no existe. Si tiramos un 'git branch' solo vamos a ver MASTER. Para poder trabajar sobre esa branch tenemos que hacer nosotros una nueva branch con el mismo nombre con un:

		git swich -C feature/change-pass origin/feature/change-pass

agregamos el path de origin/featuer/change-pass, así en nuestro repo local lo tenemos en la misma carpeta que en el repo remoto. Al ejecutar este código nos devolverá un mensaje diciendo que esta nueva branch va a trackear la branch remota feature/change-pass, por lo que ahora si podemos hacer nuevos commits en esta branch y pushearlos al repo remoto.

Para ver esto en un ejemplo, supongamos que ahora que tenemos la branch remota, alguien más sube un commit al repo remoto. Nosotros ya tenemos la branch pero nos falta este último commit, por lo que tenemos que hacer un pull. Al hacer un pull y tirar un log veremos lo siguiente:

		* 73bbc5f (HEAD -> feature/change-password, origin/feature/change-password) Update file1 
		* 478ac2a (origin/master, origin/HEAD, master) Add file1 
		* f11b0do Update README.md  
		* fb3b343 Initial commit

Ahora vemos varias cosas: nuestro HEAD está en la nueva branch feature/password, que es la misma branch remota origin/feature/change-password, ya que nuestra branch local trackea esa branch. También vemos que origin/HEAD y origin/MASTER están un commit atrás ya que nunca se hizo un merge, y tambén vemos que NUESTRO MASTER está en ese mismo commit ya que tampoco nunca hicimos un merge. Si hacemos un merge desde MASTER:

		git switch master
		git merge feature/change-password

En un nuevo log veremos:

		* 73bbc5f (HEAD -> master, origin/feature/change-password, feature/change-password) Update file1 
		* 478ac2a (origin/master, origin/HEAD) Add file1 
		* f11b0do Update README.md  
		* fb3b343 Initial commit

Ahora si vemos que nuestro MASTER mergeado, en el último commit, el mismo commit de la branch feature/change-pass. Ahora solo faltaría mover el origin/master, por lo que tenemos que hacer un 'git push', y por último, nuestro log muestra:

		* 73bbc5f (HEAD -> master, origin/master, origin/feature/change-password, origin/HEAD, feature/change-password) Update file1 
		* 478ac2a Add file1 
		* f11b0do Update README.md  
		* fb3b343 Initial commit

Ahora hay que eliminar las branches del repo remoto y del repo local con un:

		git push -d origin feature/change-pass
		git branch -d feature/change-pass

Por último, cuando la otra persona que estaba trabajando en esta branch haga un pull, se bajará la última snapshot del repo remoto, donde ya no existe la branch feature/change-pass, por lo que deberá eliminarla de su repo local. Pero por último, la otra persona todavía verá la branch feature/change-pass al tirar un 'git branch -r', por más de que la branch ya no exista, porque nunca se elimino el trackeo. Para actualizar los tracking hay que hacer un:

		git remote prune origin


-------------------

	PULL REQUEST

Sirve para compartir nuestros cambios con otras personas antes de mergear nuestros cambios master. Veamos un workflow:
Supongamos que un compañero hace una nueva feature, la persona hace una nueva branch local, hace un commit, y después pushea los cambios a GitHub:

		git switch -C feature/login
		echo hello > file3.txt
		git add .
		git commit -m "Write hello con file3"
		git push -u origin feature/login

Ahora esa persona desde la web podemos ver esta nueva branch, y haciedo click en el botón "pull request" elegir la branch base (master) y la branch a comparar (feature/login) y podrá ver un resumen de quien hizo el push, que cámbios hay comparados con master. Ahora esa persona puede crear un pull request y agregarnos a nosotros o a cualquier otro compañero para discutir los cambios. Cuando nos agregan, nos llega un mail avisando que alguien quiere que hagamos un review de ciertos cambios a mergear en master. Ahora nosotros podemos hacer un review de los cambios, aprobarlos, agregar comentarios a cada linea y hacer un request de más cambios antes de aprobar. Git muestra de forma muy intuitiva un flow de todos los cambios, el back and forth, y por último nos permite hacer un merge y borrar la branch mergeada del repo remoto con un solo botón.
Ahora supongamos que nosotros aprobamos los cambios, mergeamos y borramos la branch, ahora la persona que hizo un pull request no tiene la última snapshot o commit del repo remoto, por lo que deberá hacer un:

		git switch master
		git pull

Y en su log verá lo siguiente:

		* 26610c2 (HEAD -> master, origin/master, origin/HEAD) Merge pull request #1 from codewithmosh/feature/login
		|\
		| * a9bd6cb_(origin/feature/login, feature/login) Capitalize Hello. 
		| * ae2f039 Write hello to file3
		|/
		* 73bbc5f Update file1 
		* 012ff85 Update README.md 
		* fb3b343 Initial commit

Ahora solo le resta remover el branch local y el tracking de la branch remota que ya no existe:
		
		git branch -d feature/login
		git remote prune origin



		WORKFLOW REAL:

Para hacer un ejemplo agregé una branch local:

		git switch -C addon/guias

Después fui a mi directorio local y pegué mi guia SQL de sublime text. Tiré un status y me tiró:
	
		?? "GUIA SQL EMPEZADA TARDE"

Tire un add, commit y push para agregar los cambios a mi SA, commitir los cambios y subirlos a mi repo remoto:

		git add .
		git commit -m "Agrego GUIA SQL"
		git push -u origin addon/guias

Ahora cuando voy a la web veo el mensaje diciendo "addons/guias had a recent push" con la opción "Compare & pull request".
Cuando entro al pull request puedo ver los cambios, y abajo tengo la opción de "merge" y luego de mergear la branch 'addons/guias' a la branch 'main', me tira el botón 'delete branch'. Al borrar la branch el repo remoto me queda terminado, solo la branch main, con la guia de SQL en ella.
Vuelvo al cmd y tiro un pull, desde la branch addon/guias veo lo siguiente:

		git pull
		git log --oneline --all --graph

Deuvelve:

		*   732afae (origin/main, origin/HEAD) Merge pull request #1 from LeoneAlejandro/addon/guias
		|\
		| * 6ff90c1 (HEAD -> addon/guias, origin/addon/guias) Agrego GUIA SQL
		|/
		* d16cb1b (main) Agrego el ST GUIA GITHUB
		* 60c27c4 Add file1.txt
		* eab1893 Update README.md
		* 3478252 Update README.md
		* eb163fb Initial commit

Si ahora me muevo a main, tiro un nuevo pull:

		git switch main
		git pull

Me tira el mensaje:

		Updating d16cb1b..732afae
		Fast-forward
		 GUIA SQL EMPEZADA TARDE | 557 ++++++++++++++++++++++++++++++++++++++++++++++++
		 1 file changed, 557 insertions(+)
		 create mode 100644 GUIA SQL EMPEZADA TARDE

El último log me devuelve:

		*   732afae (HEAD -> main, origin/main, origin/HEAD) Merge pull request #1 from LeoneAlejandro/addon/guias
		|\
		| * 6ff90c1 (origin/addon/guias, addon/guias) Agrego GUIA SQL
		|/
		* d16cb1b Agrego el ST GUIA GITHUB
		* 60c27c4 Add file1.txt
		* eab1893 Update README.md
		* 3478252 Update README.md
		* eb163fb Initial commit

Ahora solo queda borrar las branches de mi repo local con:

		git branch -d addon/guias				//remueve el addon/guias pointer de la linea 6ff90c1
		git remote prune origin					//remueve el origin/addon/guias pointer de la linea 6ff90c1

Por último veo:

		*   732afae (HEAD -> main, origin/main, origin/HEAD) Merge pull request #1 from LeoneAlejandro/addon/guias
		|\
		| * 6ff90c1 Agrego GUIA SQL
		|/
		* d16cb1b Agrego el ST GUIA GITHUB
		* 60c27c4 Add file1.txt
		* eab1893 Update README.md
		* 3478252 Update README.md
		* eb163fb Initial commit



============================================


	REESCRIBIENDO HISTORIA:

Un recurso importante pero peligroso de GIT es que podemos reescribir la historia, podemos borrar o modificar commits, combinar o dividros, etc.
Cuando es conveniente hacer esto ? Cuando la historia es mala, por ej:

	- Mensajes de commits pobres
	- Commits muy grandes con temas que no se relacionan entre si
	- Commits muy pequeños dispersos por todos lados

por alguno de estos motivos tal vez no podamos extraer información importante del historial. Queremos un historial limpio, legible y facil de seguir, que explique la historia de nuestro proyecto, como evolucionó desde el día 1. Para esto podemos:

	- Reescribir los mensajes de commits para que tengan un significado y descripción importante
	- Dividir commits grandes en pequeños que representen cadenas lógicas separadas
	- Si tenemos muchos commits pequeños podemos hacer un squash de un grupo de commits que estén relacionados
	- Podemos borrar commits enviados por accidente
	- Modificar commits, por ej, nos olvidamos de agregar un archivo

Pero reescribir la historia es peligroso y hay que estar seguros.

	REGLA DE ORO:  -- "NO REESCRIBIR HISTORIA PÚBLICA"

Esto quiere decir que si en algún momento hicimos pública nuestra historia, nunca modificarlos. En realidad, los commits en el repo remoto son inmutables, no se pueden modificar, entonces cuando "modificamos" un commit, lo que realmente estamos haciendo es crear una copia EXACTA (*) y asignando a ese commit como el último, pero el commit original no se borra, siempre queda de backup. Para ver un flow, supongamos que nuestro repo local y remoto están en el mismo estado:

Local:    MASTER     │  Remoto:       MASTER
            ▼        │                  ▼
 ┌───┐    ┌───┐      │       ┌───┐    ┌───┐
 │ A │◄───┤ B │      │       │ A │◄───┤ B │
 └───┘    └───┘      │       └───┘    └───┘

Ahora supogamos que modificamos el commit B en nuestro repo local, enrealidad lo que estamos haciendo es crear una copia exacta * y después pushearla para designarla como master en nuestro repo local y remoto:

 REPO LOCAL                                                       REPO REMOTO - OP 1                                       REPO REMOTO - OP 2
             MASTER                                                                   MASTER
               ▲            Al intentar pushear git nos                                 ▲      O la otra forma es                    MASTER
    ┌───┐    ┌───┐          va a rechazar el push                   ┌───┐    ┌───┐    ┌───┐    pushear es con un -f                    ▲
    │ A │◄───┤ B*│          porque tenemos una divergencia,         │ A │◄───┤ B ├────┤ M │    lo que haría lo siguiente    ┌───┐    ┌───┐
    └───┘    └───┘          una nueva branch.Por lo que podemos     └───┘    └───┘    └─┬─┘    en el repo remoto            │ A │◄───┤ B*│
      ▲                     hacer 2 cosas:                            ▲                 │                 >>>>>>>>>>>>>>>   └───┘    └───┘
      │      ┌───┐          o hacer un merge de la siguiente manera   │      ┌───┐      │      
      └──────┤ B │                 >>>>>>>>>>>>>>>>>>>>               └──────┤ B*│◄─────┘	   Git sobreescribe B con B*
             └───┘          que nos dejará una historia sucia,               └───┘
               ▼            compleja de leer
          origin/MASTER

Esta opción 2 parece muy sencilla y deja el remoto como queremos, pero sobreescribir está extremadamente mal porque como ya dijimos, en algún momento hicimos B público, por lo que si en algún momento otra persona hizo un pull antes de hacer la modificación, esa persona está trabajando con la versión anterior de B, por lo que cuando haga un push de su nuevo commit "C" git va a rechazar el push ya que pertenece a otra branch.
Para solucionar esto, la otra persona tendrá que hacer un pull para obtener B* y hacer un merge, dejando una historia sucia y compleja sin motivo.

   REPO LOCAL DE TERCEROS                  REPO LOCAL & REMOTO DESPUES DEL PUSH
 
                       MASTER          │                        origin/MASTER & MASTER
                         ▲             │                                  ▲
      ┌───┐    ┌───┐   ┌───┐   ┌───┐   │       ┌───┐    ┌───┐           ┌───┐
      │ A │◄───┤ B │◄──┤ C │◄──┤ M │   │       │ A │◄───┤ B*│◄──────────┤ M │
      └───┘    └───┘   └───┘   └─┬─┘   │       └───┘    └───┘           └─┬─┘
        ▲                        │     │         ▲                        │
        │      ┌───┐             │     │         │      ┌───┐   ┌───┐     │
        └──────┤ B*│◄────────────┘     │         └──────┤ B │◄──┤ C │◄────┘
               └───┘                   │                └───┘   └───┘
                 ▼                     │
            origin/MASTER              │

Como vemos, el origin/MASTER va a estar en B*, pero esta persona tendrá su master en el B que luego modificamos, por lo que su commit C está basado en B, y tendrá que hacer un merge para combinar B* y C, y luego también contaminar el repo remoto una vez que pushee estos cambios, contaminando el remoto de una manera desprolija.

Por esto recordar, modificar la historia en nuestro repo privado y local antes de hacerlo público está perfecto, es hasta una buena práctica para pushear después una historia limpia, pero una vez que pusheamos algo al repo remoto, nunca modificarlo !!!


-------------------------------


	EJEMPLO REAL REPOSITORIO MERCURY:

Ahora vamos a trabajar con un nuevo repositorio para hacer todos los cambios que mencionamos hace un toque, en el repositorio "Mercury" tenemos el siguiente log:

		* 088455d (HEAD -> master) .											//El mensaje es "." no tenemos idea que es
		* f666091 WIP															//Msj: work in progress ?
		* 111bd75 Update terms of service and Google Map SDK version.			//Junta 2 cosas en un commit, separar
		* 72856ea WIP															//Msj: work in progress ?
		* 8441b05 Add a reference to Google Map SDK.							//Debería ir antes de "render"
		* 8527033 Change the color of restaurant icons.							//Mismo unit of work que "restaurant"
		* af26a96 Fix a typo.													//Commit sin sentido, solo es ruido en la historia
		* 6fb2ba7 Render restaurants the map.									//Falta la palabra "on" the map
		* 70ef834 Initial commit

En este log vemos varias cosas a arreglar: mensajes que no tienen sentido, commits de WIP que no deberían estar (supongamos que seguimos el proyecto y dentro de 3 meses volvemos a ver estos commits, que significa WIP ?), commits desordenados, o el "fix a typo" porej, es un commit que no debería existir.
Ahora vamos a solucionar la historia de este repo.


DESHACER LOS ULTIMOS COMMITS:

Decidimos que el último commit "." es innecesario y lo queremos deshacer, para este caso tenemos 2 opciones: si ya compartimos este commit al repo remoto, hay chances de que alguien haya trabajado sobre este commi, por lo que no deberíamos removerlo, deberíamos hacer un "revert" que crea un nuevo commit que deshace los cambios del commit que queremos deshacer. Para este caso deberíamos hacer un 
	
		git revert HEAD

Pero para este caso supongamos que todavía no compartimos este commit, por lo que solamente está en nuesto repo local, para eso podemos hacer la segunda opción: para esto hacemos un reset.

		git reset --hard HEAD~1

Como ya sabemos, si usamos la opción hard, no solo revertirá el commit sino también los cambios en nuestra SA y directorio local, mientras que --mixed también revertirá los cambios de la SA, y --soft solo moverá el HEAD al commit anterior, sin modificar nuestro directorio local, ni la staging area (este sería el momento exacto antes de hacer el commit anterior).
Antes de hacer el revert hay que ver que cambios hizo ese commit, esto lo podemos ver con el comando:
		
		git show HEAD

Vemos que en ese commit se agregó la linea "TEST en terms.txt, ahora si hacemos el revert:

		git reset --soft HEAD~1

Como elegimos la opción soft, ahora se revertieron los cambios solo en el repo local, por lo que si tiramos status veremos

		M terms.txt  						//M en verde porque los cambios están en el dir local y en la SA

Podemos ver la diferencia de nuestra SA con el último commit tirando el comando "git diff --cached", que nos mostrará, al igual que "git show head" que la única diferencia es la linea "TEST" en terms.txt.
Ahora para ver la diferencia vamos a cambiar el tipo de reset:

		git reset --mixed HEAD

Notar que hacemos HEAD y no HEAD~1, sino volveríamos otro commit más para atrás, aca estamos cambiando el tipo de reset del commit 088455d. Básicamente lo que está haceiendo este comando es tomar los cambios del commit en HEAD (f666091) y ponerlos en la SA.
Ahora si tiramos status veremos que la M cambió a color rojo porque los cambios SOLO están en nuestro directorio local, y no en la SA. De nuevo podemos ver la diferencia entre nuestro dir local y la SA tirando el comando "git diff" sin ningún argumento, y otra vez veremos la linea "TEST" agergados a terms.txt
Por último vamos a volver a cambiar el tipo de rest con:
		
		git reset --hard HEAD

Ahora los cambios del commit 088455d (TERST en terms.txt) también fueron revetidos de nuestro directorio local.


REVIRITIENDO COMMITS:

Siguiendo desde el último ejemplo, ahora nuestor log queda así:

		* f666091 WIP
		* 111bd75 Update terms of service and Google Map SDK version.
		* 72856ea WIP									
		* 8441b05 Add a reference to Google Map SDK.	
		* 8527033 Change the color of restaurant icons.
		* af26a96 Fix a typo.				
		* 6fb2ba7 Render restaurants the map.
		* 70ef834 Initial commit


Supongamos que ahora queremos reverit el commit f666091, pero esta vez supongamos que SI compartimos este commit, por lo que 'reset' ya no es una opción, ya que alguien pudo haber trabajado con el commit f666091, por lo que cuando esa persona suba su nuevo commit, tendrá conflictos y divergencias. Ahora si usamos la opción revert:

	 git revert HEAD 				//revierte el último commit
	 git revert HEAD~2 				//revierte el commit 72856ea solamente
	 git revert HEAD~3..HEAD 		//revierte desde HEAD hasta HEAD~3, sin incluir HEAD~3, osea desde f666091 hasta 72856ea

Si ejecutamos este último comando, git revierte UNO POR UNO los commits elegidos, haciendo, en este caso, 3 revert commits, agregando mucho ruido en la historia, y nuestro log quedarí así:
		
		* 207a873 (HEAD -> master) Revert "WIP"												//REVERT 1
		* 40a1fd0 Revert "Update terms of service and Google Map SDK version."				//REVERT 2
		* 5d8812e Revert "WIP"																//REVERT 3
		* f666091 WIP
		* 111bd75 Update terms of service and Google Map SDK version.
		* 72856ea WIP
		* 8441b05 Add a reference to Google Map SDK.
		* 8527033 Change the color of restaurant icons.
		* af26a96 Fix a typo.
		* 6fb2ba7 Render restaurants the map.
		* 70ef834 Initial commit


esto queda muy mal, sería mucho mejor si podemos revertir todos los cambios en UN SOLO commit. Para eso primero volvemos al estado anterior al revert con un:

		git reset --hard HEAD~3

Ahora vamos a hacere un reset pero sin hacer ningún commit con la opción "--no-commit", con este comando git hace todos los cambios para revertir los últimos 3 commits pero solo los agrega en la SA, entonces para cada commit que vamos a revertir git se fija que cambios hay que hacer y agrega esos cambios en la SA. Ejectuamos este cambios:

		git revert --no-commit HEAD~3..HEAD
o 		git revert --no-commit HEAD~3..

Una vez ejectuado vemos el log siguiente:

		* f666091 (HEAD -> master) WIP
		* 111bd75 Update terms of service and Google Map SDK version.
		* 72856ea WIP
		* 8441b05 Add a reference to Google Map SDK.
		* 8527033 Change the color of restaurant icons.
		* af26a96 Fix a typo.
		* 6fb2ba7 Render restaurants the map.
		* 70ef834 Initial commit

Y si tiramos un status -s veremos los siguientes cambios:
		M  map.txt
		M  package.txt
		D  terms.txt

Todo en verde ya que los cambios están en la SA. Pero todavía estamos en el proceso de reverting, por lo que podemos tirar un:

		git revert --abort
		git revert --continue

Abort obvio es para volver para atrás, continue para aceptar los cambios. En este caso ponemos continuar, guardamos el mensaje del commit que salta en VS code y terminamos.

AMENDING O ARREGLANDO EL ULTIMO COMMIT:

Hay casos donde hicimos un commit, pero después nos dimos cuenta que nos equivcamos en algo, un typo o por accidente incluimos un archivo en nuestro commit, en estos casos no tenemos que hacer un nuevo commit, podemos arreglar o modificar el último commit.
Supongamos que agregamos "cafes" a map.txt, lo agregamos a la SA, y hacemos un commit:
 
		echo caffes >> map.txt
		git commit -am "Render caffes on the map"

Ahora nos dimos cuenta que cometimos un error y queremos cambiar la linea. Para eso abrimos map.txt y lo modificamos a gusto.

		code map.txt 			//lo modificamos y guardamos
		git add .

Ahora para arreglar el último commit hacmeos un:

		git commit --amend

Hay que tener en cuenta que en realidad no arreglamos el último commit, los commits son inmutables, git en realidad creó un nuevo commit con el arreglo.


RECUPERANDO COMMITS PERDIDOS:

A veces nos equivocamos cuando reseteamos el HEAD, por ejemplo supoganmos que tenemos el siguiente log:

		* bf8df59 (HEAD -> master) Render caffes on the map
		* de12847 Revert bad code.
		* f666091 WIP
		* 111bd75 Update terms of service and Google Map SDK version.
		* 72856ea WIP
		* 8441b05 Add a reference to Google Map SDK.
		* 8527033 Change the color of restaurant icons.
		* af26a96 Fix a typo.
		* 6fb2ba7 Render restaurants

y por error ejecutamos:

		git reset --hard HEAD~6

Luego tiramos un log --all y vemos lo siguiente:

		* 8527033 Change the color of restaurant icons.
		* af26a96 Fix a typo.
		* 6fb2ba7 Render restaurants the map.
		* 70ef834 Initial commit

Podríamos pensar que perdimos todos los commits borrados, pero con git nunca se pierde nada, todos estos commits borrados todavía estan en el repositorio por un tiempo, hasta que git decida que ya no se usan más y los borra definitavmente. Como podemos hacer para recuperar los commits perdidos ? Para este caso tenemos que usar el comando "reflgo" que es un log de como nuestra referencia ha cambiado en nuestra historia:

		git reflog

En nuestro caso nos devuelve:

		8527033 (HEAD -> master) HEAD@{0}: reset: moving to HEAD~6
		bf8df59 HEAD@{1}: commit (amend): Render caffes on the map
		022a6ed HEAD@{2}: commit: Render caffes on the map
		de12847 HEAD@{3}: commit: Revert bad code.
		...

Aca vemos como el último movimiento de nuestro HEAD fue "reset: moving to HEAD~6" y ahora HEAD está apuntando al commit 8527033, pero en el paso anterior el cambio fue hecho por un commit con el mensaje "Render caffes on the map", y el HEAD estaba en el commit bf8df59, por lo que para recuperar los commits tenemos que resetear HEAD a ese commit, podemos referenciarlo por ID del commit (bf8df59), o ID del entry (HEAD@{1})

		git reset --hard HEAD@{1}

Y ahora tenemos todo igual que antes de hacer el cambio. También podemos ver la historia de otros pointers con reflog: supongamos que tenemos una branch "feature", podemos ver el historial de esta branch con el comando
	
		git reflog show feature



AMMENDAR o ARREGALR COMMITS VEIJOS:

Supongamos que tenemos de nuevo el siguiente log:

		* bf8df59 (HEAD -> master) Render caffes on the map
		* de12847 Revert bad code.
		* f666091 WIP
		* 111bd75 Update terms of service and Google Map SDK version.
		* 72856ea WIP
		* 8441b05 Add a reference to Google Map SDK.
		* 8527033 Change the color of restaurant icons.
		* af26a96 Fix a typo.
		* 6fb2ba7 Render restaurants

Y queremos arreglar el commit 8441b05 "Add a reference to Google Map SDK", primero vemos el contenido del commit con

		git show 8441b05

Y nos muestra lo siguiente:

			Author: Moshfegh Hamedani <moshfegh@live.com.au>
			Date:   Wed Sep 9 17:41:49 2020 -0700

			    Add a reference to Google Map SDK.

			diff --git a/package.txt b/package.txt
			new file mode 100644
			index 0000000..7324ece
			--- /dev/null
			+++ b/package.txt
			@@ -0,0 +1 @@
			+Google Map 1.0.0

En este caso vemos que se agregó una linea "+Google Map 1.0.0" a "package.txt", supongamos que nos olvidamos de agregar la licencia de google map, entonces queremos volver en la historia y arreglar este commit. Para hacer esto vamos a usar un rebasing; en este caso vamos a poner todos los commits posteriores al 8441b y los vamos a poner encima del commit padre de 8841b, o sea de 8527033. Esto lo hacemos de la siguiente manera:

		git rebase -i 8527033

Esto nos abrirá VSCODE con un script:

		pick 8441b05 Add a reference to Google Map SDK.
		pick 72856ea WIP
		pick 111bd75 Update terms of service and Google Map SDK version.
		pick f666091 WIP
		pick de12847 Revert bad code.
		pick bf8df59 Render caffes on the map

Esto contiene una serie de instrucciones sobre la operación rebase, en este script tenemos todos los commits que vamos a reproducir desde el más viejo al más nuevo, primero de todo vemos el commit que queremos editar, y abajo de todo el último commit que hicimos. Ahora vamos a cambiar la instrucción "pick" del commit 8441b05 por la instrucción "edit". Podríamos también cambiar tantos commits como queramos para editar. Ahora solo vamos a cambiar por "edit" el commit mencionado, pero como ya dijimos antes, cuando editamos un commit, en realidad estamos creando una copia nueva, y en este caso, no solo estamos recerando el commit 8441b05, sino que estamos recreando TODOS los commits listados en el rebase, y esto es porque supongamos que tenemos el siguiente chart, y queremos modificar de B a B*:

			 ┌───┐    ┌───┐   ┌───┐   ┌───┐
			 │ A │◄───┤ B │◄──┤ C │◄──┤ D │
			 └───┘    └───┘   └───┘   └───┘
			   ▲
			   │      ┌───┐
			   └──────┤ B*│
			          └───┘

Ahora no podemos cambiar la referencia de C a B*, por lo que tenemos que crear otra copia exacta de C (C*) que haga referencia a B*, y así con TODOS los commits después de B.
Por esto "REBASING" es una operación destructiva que cambia la historia, por lo tanto tener en cuenta de nunca hacer un rebase si compartimos estos commits.
Volviendo a nuestro caso, cerramos el VSCODE habiendo modificado "pick" por "edit" y la operación de rebase empieza y nos muestra este mensaje:

			Stopped at 8441b05...  Add a reference to Google Map SDK.
			You can amend the commit now, with

			  git commit --amend

			Once you are satisfied with your changes, run

			  git rebase --continue

Nos indica que paramos en el commit que queríamos (vemos que estamso en REBASING 1/6 en el título del cmd), y podemos arreglar lo que querramos y luego continuar, vamos entonces a agregar la licencia y hacer el commti:

		echo license >> license.txt 			//un status tira '?? license' en rojo porque agregamos el txt license
		git add .
		git commit --amend

Ahora un log nos devuelve lo siguiente:
		
		* d92b5a7 (HEAD) Add a reference to Google Map SDK.
		| * bf8df59 (master) Render caffes on the map
		| * de12847 Revert bad code.
		| * f666091 WIP
		| * 111bd75 Update terms of service and Google Map SDK version.
		| * 72856ea WIP
		| * 8441b05 Add a reference to Google Map SDK.
		|/
		* 8527033 Change the color of restaurant icons.
		* af26a96 Fix a typo.
		* 6fb2ba7 Render restaurants the map.
		* 70ef834 Initial commit

Ahora tenemos 2 branches, la original a la derecha, y la nueva con un solo commit, el arreglado, a la izquierda. Ahora al seguir con el rebase, se agregarán todos los commits posteriores al viejo 8441b05 y los pondrá después del nuevo d92b5a7. Veamos:
	
		git rebase --continue 				//si nos equivocamos podemos hacer un --abort para volver al estado anterior del rebase

Y ahora vemos el nuevo log:

		* 1c563eb (HEAD -> master) Render caffes on the map
		* d9b311c Revert bad code.
		* 53656c1 WIP
		* 886f866 Update terms of service and Google Map SDK version.
		* 250a31b WIP
		* d92b5a7 Add a reference to Google Map SDK.
		* 8527033 Change the color of restaurant icons.
		* af26a96 Fix a typo.
		* 6fb2ba7 Render restaurants the map.
		* 70ef834 Initial commit

Donde todos los commits tienen el mismo mensaje, pero todos después del 8527033 cambiaron de ID ya que en realidad son una copia de los originales + el cambio que hicimos. La diferencia entre el "d9b311c Revert bad code" nuevo y el "* de12847 Revert bad code" viejo es que el nuevo contiene license.txt en el, que es el cambio que hicimos. 



ELIMINAR UN COMMIT / DROPPING A COMMIT:

Digamos que queremos eliminar el commit 250a31b de nuestra historia:

		* 1c563eb (HEAD -> master) Render caffes on the map
		* d9b311c Revert bad code.
		* 53656c1 WIP
		* 886f866 Update terms of service and Google Map SDK version.
		* 250a31b WIP
		* d92b5a7 Add a reference to Google Map SDK.
		* 8527033 Change the color of restaurant icons.
		* af26a96 Fix a typo.
		* 6fb2ba7 Render restaurants the map.
		* 70ef834 Initial commit

Antes de eliminarlo veamos el contenido:

			Author: Moshfegh Hamedani <moshfegh@live.com.au>
			Date:   Wed Sep 9 17:42:00 2020 -0700

			    WIP

			diff --git a/terms.txt b/terms.txt
			new file mode 100644
			index 0000000..f3d4377
			--- /dev/null
			+++ b/terms.txt
			@@ -0,0 +1 @@
			+draft

Vemos que se agregó un nuevo file llamado terms.txt con una sola linea "draft", ahora vemoas el siguiente commit con un "git show 886f866"

1			diff --git a/package.txt b/package.txt
2			index 7324ece..5111c93 100644
3			--- a/package.txt
4			+++ b/package.txt
5			@@ -1 +1 @@
6			-Google Map 1.0.0
7			+Google Map 2.0.0
8			diff --git a/terms.txt b/terms.txt
9			index f3d4377..6ab9fed 100644
10			--- a/terms.txt
11			+++ b/terms.txt
12			@@ -1 +1 @@
13			-draft
14			+completed

Vemos que hay un update en package.txt, cambiamos la lina 6 por la 7, también vemos un cambio en terms.txt, cambiamos "draft" por "completed". Si intentamos ahora borrar el commit 250a31b vamos a tener un conflicto, ya que nunca se habría creado el file terms.txt, que el commit siguiente modifica. Veámoslo entonces, haremos un rebase desd el commit padre del 250a31b, lo podemos referenciar por número (d92b5a7), por 250a31b~1 o podemos usar el siguiente símbolo que significa "el padre" del commit que estamos eligiendo

		git rebase -i 250a31b^

Nos devolverá lo siguiente:

		pick 250a31b WIP
		pick 886f866 Update terms of service and Google Map SDK version.
		pick 53656c1 WIP
		pick d9b311c Revert bad code.
		pick 1c563eb Render caffes on the map

Donde tendremos que cambiar "pick" por "drop" o eliminar la linea del commit a dropear y luego resolver el conflicto que nos devuelve:

		CONFLICT (modify/delete): terms.txt deleted in HEAD and modified in 886f866 (Update terms of service and Google Map SDK version.).  Version 886f866 (Update terms of service and Google Map SDK version.) of terms.txt left in tree.
		error: could not apply 886f866... Update terms of service and Google Map SDK version.
		hint: Resolve all conflicts manually, mark them as resolved with
		hint: "git add/rm <conflicted_files>", then run "git rebase --continue".
		hint: You can instead skip this commit: run "git rebase --skip".
		hint: To abort and get back to the state before "git rebase", run "git rebase --abort".
		Could not apply 886f866... Update terms of service and Google Map SDK version.

Ahora para ver un poco mejor esto podemos tirar un status que nos devuelve lo siguiente:

		M  package.txt
		DU terms.txt

Donde M está en verde (todo OK), pero el DU está en ROJO. DU significa que el conflicto se da porque primero, en el dropeo del commit 250a31b, lo intenta eliminar (D=DELETE) y por otro lado, en el siguiente commit 886f866 lo está intentando actualizar (U=UPDATE). Si tiramos un log vemos lo siguiente:

		* 1c563eb (master) Render caffes on the map
		* d9b311c Revert bad code.
		* 53656c1 WIP
		* 886f866 Update terms of service and Google Map SDK version.
		* 250a31b WIP
		* d92b5a7 (HEAD) Add a reference to Google Map SDK.
		* 8527033 Change the color of restaurant icons.
		* af26a96 Fix a typo.
		* 6fb2ba7 Render restaurants the map.
		* 70ef834 Initial commit

Le dijimos a git que queremos dropear el commit 250a31b, por lo que está intentando deshacer los cambios que hicimos en ese commit, en este caso está intentando deshacerse del archivo añiadido en este commit. Ahora los cambios que tengamos en la SA (eliminar el file) van a ir al siguiente commi, donde  teníamos un UPDATE del archivo a eliminar por el commit anterior y la modificación de package.txt. Ahora necesitamos resolver el conflicto, podemos hacerlo mediante:

		git mergtool

que nos devuelve:

		Deleted merge conflict for 'terms.txt':
		  {local}: deleted
		  {remote}: modified file
		Use (m)odified or (d)eleted file, or (a)bort?

En este caso vamos a elegir la modificación, porque queremos tener el terms.txt, y luego continuamos con el rebasing.
Por último nos queda el siguiente log:

		* d37c81d (HEAD -> master) Render caffes on the map
		* 8226a1f Revert bad code.
		* 9de62ac WIP
		* 23fbfa3 Update terms of service and Google Map SDK version.
		* d92b5a7 Add a reference to Google Map SDK.
		* 8527033 Change the color of restaurant icons.
		* af26a96 Fix a typo.
		* 6fb2ba7 Render restaurants the map.
		* 70ef834 Initial commit

Ya no tenemos el commit 250a31b WIP, y también vemos que todos los commits posteriores cambiaron de ID nuevamente ya que hicimos un rebasing. Ahora como último ejemplo vamos a eliminar los commits 9de62ac y 8226a1f para dejar más limpia la historia.

		git rebase -i HEAD~3

Nos devuelve:

		pick 9de62ac WIP
		pick 8226a1f Revert bad code.
		pick d37c81d Render caffes on the map

Borramos las 2 primeras lineas para dropear esos commits, en este caso no tuvimos ningún conflicto, y si tiramos un nuevo log nos queda:

		* 9d771c1 (HEAD -> master) Render caffes on the map
		* 23fbfa3 Update terms of service and Google Map SDK version.
		* d92b5a7 Add a reference to Google Map SDK.
		* 8527033 Change the color of restaurant icons.
		* af26a96 Fix a typo.
		* 6fb2ba7 Render restaurants the map.
		* 70ef834 Initial commit

Una historia mucho más limpia y facil de leer con todos los mismos cambios desde el principio.




CAMBIAR MENSAJE DE COMMIT / REWORDING COMMIT MESSAGES:

Supongamos que queremos arreglar el mensaje del commit 6fb2ba7 y agregarle "on" antes "the map". Ahora hacemos de nuevo un rebasing desde el commit padre del que queremos modificar:

		git rebase -i 6fb2ba7^

Nos abre VSCODE con:

		pick 6fb2ba7 Render restaurants the map.
		pick af26a96 Fix a typo.
		pick 8527033 Change the color of restaurant icons.
		pick d92b5a7 Add a reference to Google Map SDK.
		pick 23fbfa3 Update terms of service and Google Map SDK version.
		pick 9d771c1 Render caffes on the map

Y vamos a cambiar "pick" por "reword" en los commits que querramos renombrar. En este caso queremos también renombrar el commit d92b5a7, por lo que también cambiamos pick por reword. Ahora cuando guardamos y cerramos el VSCODE, git va a hacer el rebase y va a frenar en los que cambiamos "pick" por "reword" y nos va a pedir el nuevo mensaje del commit en una nueva ventana de VSCODE, al igual que cuando hacemos un -commit sin el mensaje en cmd.
Luego nos tira que el rebasing fue exitoso, y si tiramos el último log veremos:

		* c0f6b12 (HEAD -> master) Render caffes on the map
		* 29dbf95 Update terms of service and Google Map SDK version.
		* b193450 Add a reference to Google Map SDK v1.0.					//Agregamos v1.0 al final
		* 53819ff Change the color of restaurant icons.
		* 6956c6e Fix a typo.
		* b9b5e6f Render restaurants on the map.							//Arreglado ON THE MAP
		* 70ef834 Initial commit

Y vemos de nuevo que todos los ID cambiaron otra vez, ya que son todas copias nuevas de commits anteriores, por lo que esto no se debería hacer si ya compartimos estos commits. Solo hacerlo con archivos de nuestro repo local.


REORDENANDO COMMITS / REORDERING COMMITS:

Volviendo a ver nuestro log:

		* c0f6b12 (HEAD -> master) Render caffes on the map
		* 29dbf95 Update terms of service and Google Map SDK version.
		* b193450 Add a reference to Google Map SDK v1.0.		
		* 53819ff Change the color of restaurant icons.
		* 6956c6e Fix a typo.
		* b9b5e6f Render restaurants on the map.	
		* 70ef834 Initial commit

Vemos que tenemos un commit desordenado, que está en una mala posición. En el commit b193450 dice que añade una referencia en Google Map después de que el commit b9b5e6f implemente una feature que depende de google map, por lo que si hacemos un checkout al commit b9b5e6f y ejecutamos la app, no va a funcionar, ya que le falta la referencia a google map para hacer el render, por lo que ahora vamos a mover el commit b193450 y vamos a bajarlo, de nuevo con un rebase desde el commit anterior al "Render restaurants on the map"

		git rebase -i 70ef834

Nos abre VSCODE con todos los commits desde el más viejo hasta el más nuevo:

		pick b9b5e6f Render restaurants on the map.
		pick 6956c6e Fix a typo.
		pick 53819ff Change the color of restaurant icons.
		pick b193450 Add a reference to Google Map SDK v1.0.
		pick 29dbf95 Update terms of service and Google Map SDK version.
		pick c0f6b12 Render caffes on the map

Ahora nos paramos sobre la linea del commit b193450 y lo movemos para arriba (se puede con alt + flechitas)

		pick b193450 Add a reference to Google Map SDK v1.0.
		pick b9b5e6f Render restaurants on the map.
		pick 6956c6e Fix a typo.
		pick 53819ff Change the color of restaurant icons.
		pick 29dbf95 Update terms of service and Google Map SDK version.
		pick c0f6b12 Render caffes on the map

Ahora nuestro commit está en la posición adecuada. Guardamos, cerramos y vemos el log en el orden que queríamos:

		* c15f071 (HEAD -> master) Render caffes on the map
		* 6b33dc3 Update terms of service and Google Map SDK version.
		* 249fa2b Change the color of restaurant icons.
		* 20894aa Fix a typo.
		* d8db9c0 Render restaurants on the map.
		* 93d6a79 Add a reference to Google Map SDK v1.0.
		* 70ef834 Initial commit


UNIENDO COMMITS / SQUASHING COMMITS:

Como vimos en el último log:

1		* c15f071 (HEAD -> master) Render caffes on the map
2		* 6b33dc3 Update terms of service and Google Map SDK version.
3		* 249fa2b Change the color of restaurant icons.
4		* 20894aa Fix a typo.
5		* d8db9c0 Render restaurants on the map.
6		* 93d6a79 Add a reference to Google Map SDK v1.0.
7		* 70ef834 Initial commit

Los commits de las lineas 3, 4 y 5, todos los cambios forman parte de la misma unidad de trabajo, por lo que idealmente tendríamos que encapsular todos estos commits en una sola snapshot. Entonces vamos a hacer un squash desde el commit d8db9c0, por lo que arrancamos desde el padre de este commit:

		git rebase -i 93d6a79

Nos abre VSCODE con:

1		pick d8db9c0 Render restaurants on the map.
2		pick 20894aa Fix a typo.
3		pick 249fa2b Change the color of restaurant icons.
4		pick 6b33dc3 Update terms of service and Google Map SDK version.
5		pick c15f071 Render caffes on the map

Ahora tenemos que cambiar el "pic" de la linea 2 del commit 20894aa por "squash", lo que hará este cambio es unir el commit elegido con el anterior, por lo que si queremos unir 3 seguidos, deberíamos también cambiar por squash la linea siguiente:
Entonces, el squash de la linea 2, une las lineas 1 y 2, y el segundo squash une las lineas 3 y la linea anterior, que es el resulado de la union de las lineas 1 y 2.

1		pick 	d8db9c0 Render restaurants on the map.
2		squash 	20894aa Fix a typo.
3		squash 	249fa2b Change the color of restaurant icons.
4		pick 	6b33dc3 Update terms of service and Google Map SDK version.
5		pick 	c15f071 Render caffes on the map

En el caso de que las lineas que querramos unir no son contiguas, deberíamos reordenarlas primero. Le damos guardar y por defecto nos traer para guardar un mensaje que es la union de los 3 mensajes de commits squasheados, en este caso borramos los mensajes de los 2 commits que desaparecen y dejamos solo el mensaje de "render...". Ahora si tiramos un nuevo log veremos:

		* 795a517 (HEAD -> master) Render caffes on the map
		* 977ad45 Update terms of service and Google Map SDK version.
		* 918c06a Render restaurants on the map.
		* 93d6a79 Add a reference to Google Map SDK v1.0.
		* 70ef834 Initial commit

Tal como queríamos. Un comando similar es "fixup" que hace lo mismo pero no toma el mensaje de la linea con "fixup":

1		pick 	d8db9c0 Render restaurants on the map.
2		fixup 	20894aa Fix a typo.
3		fixup 	249fa2b Change the color of restaurant icons.
4		pick 	6b33dc3 Update terms of service and Google Map SDK version.
5		pick 	c15f071 Render caffes on the map

por lo que al terminar el rebase git no nos abre el VSCODE para elegir el mensaje del commit, sino que toma el de la primera linea "Render..." e ignora el mensaje de las siguientes dos lineas con "fixup" en vez de "squash".


DIVIENDO UN COMMIT / SPLITTING A COMMIT:

Viendo el último log tenemos:

		* 795a517 (HEAD -> master) Render caffes on the map
		* 977ad45 Update terms of service and Google Map SDK version.
		* 918c06a Render restaurants on the map.
		* 93d6a79 Add a reference to Google Map SDK v1.0.
		* 70ef834 Initial commit

Como vemos, el commit 977ad45 tiene 2 unidades de trabajo juntas "Update terms of service" y "Update Google Map SDK version". Esto deberían ser 2 commits separados y auqe no se relacionan entre si. De nuevo hacemos un rebase interactivo desde el padre del commit a modificar:

		git rebase -i 977ad45^

Nos devuelve:

		pick 977ad45 Update terms of service and Google Map SDK version.
		pick 795a517 Render caffes on the map

Cambiamos el "pick" de la primera linea por "edit", y cuando guardemos git frena en este commit y nos da la chance de editarlo y dividirlo.
Ahora si vemos el log 

		* 795a517 (master) Render caffes on the map
		* 977ad45 (HEAD) Update terms of service and Google Map SDK version.
		* 918c06a Render restaurants on the map.
		* 93d6a79 Add a reference to Google Map SDK v1.0.
		* 70ef834 Initial commit

vemos que HEAD está apuntando al commit a editar, podemos usar el comando reset para ir al estado antes de hacer este commit:

		git reset --mixed HEAD^				//mixed es la opción default, no hace falta aclararlo

Con esto vamos un paso antes de hacer este commit a editar, por lo que los cambios van a estar en nuestro directorio local, y podremos agregarlos a la SA y commitirlos separadamente. Si ahora tiramos un status vemos:

		M package.txt
		?? terms.txt

Ambos en rojo ya que como usamos --mixed los cambios están en el dir local pero no en la SA. Ahora podemos agregar y commitir estos cambios por separados haciendo:

		git add package.txt
		git commit -m "Update Google Map SDK Version 1.0 -> 2.0"

Ahora nuestro historial es el siguiente:

		* 735723c (HEAD) Update Google Map SDK Version 1.0 -> 2.0
		| * 795a517 (master) Render caffes on the map
		| * 977ad45 Update terms of service and Google Map SDK version.
		|/
		* 918c06a Render restaurants on the map.
		* 93d6a79 Add a reference to Google Map SDK v1.0.
		* 70ef834 Initial commit

Vemos la divergencia en el inciio del rebase. Ahora nos queda un solo cambio si vemos el status -s:

		?? terms.txt

Por lo que podemos agregarlo en otro commit

		git add .
		git commit -m "Update terms of service"

Luego nuestro log queda así:

		* fc9b63d (HEAD) Add terms of service
		* 735723c Update Google Map SDK Version 1.0 -> 2.0
		| * 795a517 (master) Render caffes on the map
		| * 977ad45 Update terms of service and Google Map SDK version.
		|/
		* 918c06a Render restaurants on the map.
		* 93d6a79 Add a reference to Google Map SDK v1.0.
		* 70ef834 Initial commit

Ahora tenemos el commit 977ad45 separado en los commits 735723c y fc9b63d en nuestro nuevo historial, y al continuar el rebase, seguirá agregando los commits que faltaba, quedando por último, este log:

		* 903d518 (HEAD -> master) Render caffes on the map
		* fc9b63d Add terms of service
		* 735723c Update Google Map SDK Version 1.0 -> 2.0
		* 918c06a Render restaurants on the map.
		* 93d6a79 Add a reference to Google Map SDK v1.0.
		* 70ef834 Initial commit

Y por fin tenemos los commits por separado y un historial mejor.