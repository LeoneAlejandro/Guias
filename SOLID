SOLID

En ingeniería de software, SOLID (Single responsibility, Open-closed, Liskov substitution, Interface segregation and Dependency inversion) es un acrónimo mnemónico introducido por Robert C. Martin a comienzos de la década del 2000 que representa cinco principios básicos de la programación orientada a objetos y el diseño. Cuando estos principios se aplican en conjunto es más probable que un desarrollador cree un sistema que sea fácil de mantener y ampliar con el tiempo. Los principios SOLID son guías que pueden ser aplicadas en el desarrollo de software para eliminar malos diseños provocando que el programador tenga que refactorizar el código fuente hasta que sea legible y extensible.

┌───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ Inicial /	Acrónimo /	Concepto                                                                                                    │
├───┬─────┬─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ S │ SRP │	Principio de responsabilidad única (Single responsibility principle):                                                   │
│   │     │     Una clase debe tener una solo propósito y no debe tener funcionalidad exceciva.                                     │
├───┼─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ O │ OCP │	Principio de abierto/cerrado (Open/closed principle):                                                                   │
│   │     │     Las "entidades de software" deben estar abiertas para su extensión, pero cerradas para su modificación”.            │
│   │     │     En otras palabras, no se debe reescribir una clase o entidad existente para implementar nuevas features             │
├───┼─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ L │ LSP │	Principio de sustitución de Liskov (Liskov substitution principle):                                                     │
│   │     │     Los “objetos de un programa deberían ser reemplazables por instancias de sus subtipos sin alterar el correcto       │
│   │     │     funcionamiento del programa”.                                                                                       │
│   │     │     En otras palabras, todas las subclases o clases derivadas podrán ser sustituibles por sus superclases o clases      │
│   │     │     base sin modificar su comportamiento.                                                                               │
├───┼─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ I │ ISP │	Principio de segregación de la interfaz (Interface segregation principle):                                              │
│   │     │     “Muchas interfaces cliente específicas son mejores que una interfaz de propósito general”. Las interfaces no deben  │
│   │     │     forzar a las clases a implementar lo que no pueden hacer. Y, interfaces grandes deben ser divididas en muchas       │
│   │     │     interfaces pequeñas.                                                                                                │
├───┼─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ D │ DIP │	Principio de inversión de la dependencia (Dependency inversion principle):                                              │
│   │     │     Los componentes “depender de abstracciones, no depender de implementaciones”.                                       │
│   │     │     La Inyección de Dependencias es uno de los métodos que siguen este principio.                                       │
└───┴─────┴─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘