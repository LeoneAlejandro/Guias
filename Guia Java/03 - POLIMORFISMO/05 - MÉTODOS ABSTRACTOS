MÉTODOS ABSTRACTOS

Ya vimos que podemos usar el modificador "abstract" para determinar si queremos una clase sea instanciable o no. En los casos donde una superclase es muy genérica y sirve solo para modelizar y dar herencia a otras superclases -ej: superclase fish, subclases, atun, salmon, etc- hemos aprendido que podemos declararla como abstracta así prohibimos que la misma se instancie -nunca tendremos una instancia u objeto fish, pero si subclases de fish.
Lo mismo podemos hacer con los métodos: como vimos en el ejemplo de la superclase vehículos con subclases aviones y bicis eléctricas, tanto la superclase como las subclases poseían el método "encender()", pero, porqué tendría un método encender un vehículo que de por si es abstracto ? Que estaríamos encendiendo ? La respuesta es que nada, el método encender() debe existir en la superclase, para poder delegarla al método con el mismo nombre de la sublcase. Los métodos encender de las sublcases están muy bien definidos, de la siguiente manera:

	public class BicicletaEléctrica extends Vehículo {
			@Override
			public void encender(){
				prenderPantalla();
				energizarMotor();
			}
	}

	public class Avion extends Vehículo {
			@Override
			public void encender(){
				calentarCarburador();
				regularMezcaCombustible();
				inyectarCombustible();
				masPasos();
			}

Perfecto pero, como modelamos el método encender() de la superclase vehículo ? Como se "encendería" un vehículo ? Como vemos, es muy dificil de modelar, por lo tanto, por un lado estamos obligados a definir al método en la superclase para que la misma lo derive a los métodos con misma firma de las subclases, pero al mismo tiempo no podemos definir el método en la superclase. Para esto se usa el "abstact" en los métodos: cuando definimos un método como "abstract" el mismo no puede tener implementación, se cierra la linea sólo con un ";" sin ninguna lógica adentro. Solo definimos el modificador de visibilidad (public, protected, pero NUNCA privados), el tipo de retorno de la funcion (double, boolean, etc), y si llevara parámetros los definimos también.

	public abstract void encender();

Ciertas reglas a seguir son que; los métodos abstractos nunca pueden ser privados porque sino no podríamos sobreescribirlos, y además, si una clase tiene al menos un método abstracto, la clase deberá también ser abstracta. Esto último es muy lógico ya que si una clase no es abstracta, la misma puede instanciarse -podemos instanciar un vehículo-, y al llamarse al método "encender()" si o si hará referencia al método de la superclase (no puede delegarlo a ninguna subclase) y ese metodo fue definido abstracto con anterioridad, llegando a una inconsistencia total ya que el mismo no tiene ni siquiera implementación.
Entonces al definir un método como abstacto permite OBLIGAR a las sublcases a sobreescribirlo si es que se prendenden poder ser instanciables.
En el diagrama UML los métodos, al igual que las clases, se indican como abstactas mediante la escritura itálica.
NO aplicar la abstacción a todos los métodos de las superclases! Siempre analizar bien si la superclase puede ser instanciada o no. En el caso de la superclase bicicleta y subclase bicicleta eléctrica, la superclase bicicleta va a ser instanciada y tiene todo sus atributos en ella; estaría mal aplicada la abstacción de los métodos, que nos obligarán a hacer abstracta también a la superclaclase Bicicleta, y crear una nueva subclase "BicicletaComún" (y volver a sobreescribir los métodos en la subclase, pidiendole a su superclase todos los atributos para manejarlos en los métodos).